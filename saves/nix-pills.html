<h1>Chapter 0. This Unholy Page</h1>

<div>
        <p>Didn't have time to figure out how to build the pills into one HTML file, so just generated them using <code>nix-build release.nix</code> as the README said, and the combined them with <code>cat &lt;chapters-output-list&gt; &gt; combined.html</code> where <code>&lt;chapters-output-list&gt;</code> is a placeholder for the chapter HTMLs in the order specified in <a href="https://github.com/toraritte/nix-pills/blob/master/book.xml"><code>book.xml</code></a>.</p>
</div>

<hr>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. Why You Should Give it a Try</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="pr01.html" title="Preface" /><link rel="next" href="install-on-your-running-system.html" title="Chapter 2. Install on Your Running System" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Why You Should Give it a Try</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pr01.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="install-on-your-running-system.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="why-you-should-give-it-a-try"></a>Chapter 1. Why You Should Give it a Try</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320849552"></a>1.1. Introduction</h2></div></div></div><p>
      Welcome to the first post of the "<a class="link" href="https://nixos.org/nix" target="_top">Nix</a> in pills" series.
      Nix is a purely functional package manager and deployment
      system for POSIX.
    </p><p>
      There's a lot of documentation that describes what Nix, <a class="link" href="https://nixos.org/nixos" target="_top">NixOS</a> and related
      projects are.
      But the purpose of this post is to convince you to give Nix a try.
      Installing NixOS is not required, but sometimes I may refer to
      NixOS as a real world example of Nix usage for building a whole
      operating system.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320846560"></a>1.2. Rationale for this series</h2></div></div></div><p>
      The <a class="link" href="https://nixos.org/nix/manual/" target="_top">Nix</a>,
      <a class="link" href="https://nixos.org/nixpkgs/manual/" target="_top">Nixpkgs</a>, and
      <a class="link" href="https://nixos.org/nixos/manual/" target="_top">NixOS</a> manuals;
      and wiki are excellent resources for explaining how Nix/NixOS works, how
      you can use it, and the number of cool things being done with it.
      However, at the beginning you may feel that some of the magic
      which happens behind the scenes is hard to grasp.
    </p><p>
      This series aims to complement the existing explanations from the
      more formal documents.
    </p><p>
      The following is a description of Nix. Just as with pills, I'll try to be as
      short as possible.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320842208"></a>1.3. Not being purely functional</h2></div></div></div><p>
       Most, if not all, widely used package managers (<a class="link" href="https://wiki.debian.org/dpkg" target="_top">dpkg</a>, <a class="link" href="http://www.rpm.org/" target="_top">rpm</a>, ...) mutate the
       global state of the system. If a package
       <code class="literal">foo-1.0</code> installs a program to
       <code class="filename">/usr/bin/foo</code>, you cannot install
       <code class="literal">foo-1.1</code> as well, unless you change the
       installation paths or the binary name.
       But changing the binary names means breaking users of
       that binary.
     </p><p>
       There are some attempts to mitigate this problem.
       Debian, for example, partially solves the problem with the
       <a class="link" href="https://wiki.debian.org/DebianAlternatives" target="_top">alternatives</a>
        system.
     </p><p>
       So while in theory it's possible with some current systems to install
       multiple versions of the same package, in practice it's very
       painful.
     </p><p>
       Let's say you need an nginx service and also an nginx-openresty
       service. You have to create a new package that changes all the
       paths to have, for example, an <code class="literal">-openresty</code> suffix.
     </p><p>
       Or suppose that you want to run two different instances of mysql: 5.2 and
       5.5. The same thing applies, plus you have to also make sure the two
       mysqlclient libraries do not collide.
     </p><p>
       This is not impossible but it <span class="emphasis"><em>is</em></span> very inconvenient.
       If you want to install two whole stacks of software like GNOME 3.10 and GNOME
       3.12, you can imagine the amount of work.
     </p><p>
       From an administrator's point of view: you can use containers. The
       typical solution nowadays is to create a container per service,
       especially when different versions are needed. That somewhat
       solves the problem, but at a different level and with other
       drawbacks. For example, needing orchestration tools, setting up a shared
       cache of packages, and new machines to monitor rather than
       simple services.
     </p><p>
       From a developer's point of view: you can use virtualenv for python, or jhbuild
       for gnome, or whatever else. But then how do you mix the two stacks?
       How do you avoid recompiling the same thing when it could
       instead be shared? Also you need to set up your development
       tools to point to the different directories where libraries are
       installed. Not only that, there's the risk that some of the software
       incorrectly uses system libraries.
     </p><p>
       And so on. Nix solves all this at the packaging level and
       solves it well. A single tool to rule them all.
     </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320833408"></a>1.4.  Being purely functional</h2></div></div></div><p>
       Nix makes no assumptions about the global state of the system.
       This has many advantages, but also some drawbacks of course.
       The core of a Nix system is the Nix store, usually
       installed under <code class="filename">/nix/store</code>, and some tools to manipulate the
       store. In Nix there is the notion of a <span class="emphasis"><em>derivation</em></span> rather than a
       package. The difference can be subtle at the beginning, so I
       will often use the words interchangeably.
     </p><p>
       Derivations/packages are stored in the Nix store as follows:
       <code class="filename">/nix/store/<em class="replaceable"><code>hash-name</code></em></code>,
       where the hash uniquely identifies the derivation (this isn't quite true,
       it's a little more complex), and the name is the name of
       the derivation.
     </p><p>
       Let's take a bash derivation as an example:
       <code class="filename">/nix/store/s4zia7hhqkin1di0f187b79sa2srhv6k-bash-4.2-p45/</code>.
       This is a directory in the Nix store which contains <code class="filename">bin/bash</code>.
     </p><p>
       What that means is that there's no <code class="filename">/bin/bash</code>, there's only that
       self-contained build output in the store. The same goes for
       coreutils and everything else. To make them convenient
       to use from the shell, Nix will arrange for binaries to appear in
       your <code class="varname">PATH</code> as appropriate.
     </p><p>
       What we have is basically a store of all packages (with different versions
       occupying different locations), and everything in the Nix store is immutable.
     </p><p>
       In fact, there's no ldconfig cache either. So where does bash find libc?
     </p><pre class="screen">$ ldd  `which bash`
libc.so.6 =&gt; /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/libc.so.6 (0x00007f0248cce000)
</pre><p>
       It turns out that when bash was built, it was built against that specific
       version of glibc in the Nix store, and at runtime it will require exactly that
       glibc version.
     </p><p>
       Don't be confused by the version in the derivation name:
       it's only a name for us humans. You may end up having two derivations with
       the same name but different hashes: it's the hash that really matters.
     </p><p>
       What does all this mean? It means that you could run mysql 5.2 with glibc-2.18,
       and mysql 5.5 with glibc-2.19. You could use your python module
       with python 2.7 compiled with gcc 4.6 and the same python
       module with python 3 compiled with gcc 4.8, all in the same
       system.
     </p><p>
       In other words: no dependency hell, not even a dependency
       resolution algorithm. Straight dependencies from derivations to
       other derivations.
     </p><p>
       From an administrator's point of view: if you want an old PHP version for
       one application, but want to upgrade the rest of the system, that's not painful any more.
     </p><p>
       From a developer's point of view: if you want to develop webkit with llvm
       3.4 and 3.3, that's not painful any more.
     </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320822304"></a>1.5. Mutable vs. immutable</h2></div></div></div><p>
       When upgrading a library, most package managers replace it in-place.
       All new applications run afterwards with the new library
       without being recompiled. After all, they all refer dynamically
       to <code class="filename">libc6.so</code>.
     </p><p>
       Since Nix derivations are immutable, upgrading a library like glibc
       means recompiling all applications, because the glibc path to
       the Nix store has been hardcoded.
     </p><p>
       So how do we deal with security updates? In Nix we have some
       tricks (still pure) to solve this problem, but that's another
       story.
     </p><p>
       Another problem is that unless software has in mind a pure
       functional model, or can be adapted to it, it can be hard to compose
       applications at runtime.
     </p><p>
       Let's take Firefox for example. On most systems, you install flash,
       and it starts working in Firefox because Firefox looks in a global path for plugins.
     </p><p>
       In Nix, there's no such global path for plugins. Firefox
       therefore must know explicitly about the path to flash. The way
       we handle this problem is to wrap
       the Firefox binary so that we can setup the necessary environment to make
       it find flash in the nix store. That will produce a new Firefox
       derivation: be aware that it takes a few seconds, and it makes
       composition harder at runtime.
     </p><p>
       There are no upgrade/downgrade scripts for your data. It doesn't make
       sense with this approach, because there's no real derivation to
       be upgraded. With Nix you switch to using other software with
       its own stack of dependencies, but there's no formal notion of
       upgrade or downgrade when doing so.
     </p><p>
       If there is a data format change, then migrating to the new data format remains
       your own responsibility.
     </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320817104"></a>1.6. Conclusion</h2></div></div></div><p>
       Nix lets you compose software at build time with maximum
       flexibility, and with builds being as reproducible as possible.
       Not only that, due to its nature deploying systems in the cloud is
       so easy, consistent, and reliable that in the Nix world all
       existing self-containment and orchestration tools are
       deprecated by <a class="link" href="http://nixos.org/nixops/" target="_top">NixOps</a>.
     </p><p>
       It however <span class="emphasis"><em>currently</em></span> falls short when
       working with dynamic composition at runtime or replacing low
       level libraries, due to the need to rebuild dependencies.
     </p><p>
       That may sound scary, however after running NixOS on both a
       server and a laptop desktop, I'm very satisfied so far. Some of
       the architectural problems just need some man-power, other
       design problems still need to be solved as a community.
     </p><p>
       Considering <a class="link" href="https://nixos.org/nixpkgs/" target="_top">Nixpkgs</a> (<a class="link" href="https://github.com/NixOS/nixpkgs" target="_top">github
       link</a>) is a completely new repository of all the existing
       software, with a completely fresh concept, and with few core
       developers but overall year-over-year increasing contributions,
       the current state is more than acceptable and beyond the
       experimental stage. In other words, it's worth your investment.
     </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320811488"></a>1.7. Next pill...</h2></div></div></div><p>
       ...we will install Nix on top of your current system (I assume
       GNU/Linux, but we also have OSX users) and start inspecting the
       installed software.
     </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pr01.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="install-on-your-running-system.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Preface </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 2. Install on Your Running System</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 2. Install on Your Running System</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="why-you-should-give-it-a-try.html" title="Chapter 1. Why You Should Give it a Try" /><link rel="next" href="enter-environment.html" title="Chapter 3. Enter the Environment" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. Install on Your Running System</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="why-you-should-give-it-a-try.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="enter-environment.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="install-on-your-running-system"></a>Chapter 2. Install on Your Running System</h1></div></div></div><p>
    Welcome to the second Nix pill. In the <a class="link" href="why-you-should-give-it-a-try.html" title="Chapter 1. Why You Should Give it a Try">first</a> pill we
    briefly described Nix.
  </p><p>
    Now we'll install Nix on our running system and understand what
    changed in our system after the installation.
    <span class="bold"><strong>If you're using NixOS, Nix is already installed;
    you can skip to the <a class="link" href="enter-environment.html" title="Chapter 3. Enter the Environment">next</a> pill.</strong></span>
  </p><p>
     <a class="link" href="https://nixos.org/nix/manual/#chap-installation" target="_top">Installing
     Nix</a> is as easy as installing any other package.
     It will not drastically change our system, it will stay out of our way.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320803552"></a>2.1. Installation</h2></div></div></div><p>
      To install Nix, run <span class="command"><strong>curl -L https://nixos.org/nix/install | sh</strong></span>
      as a non-root user and follow the instructions. Alternatively, you may
      prefer to download the installation script and verify its integrity using
      GPG signatures. Instructions for doing so can be found here: <a class="link" href="https://nixos.org/nix/download.html" target="_top">https://nixos.org/nix/download.html</a>.
    </p><p>
      These articles are not a tutorial on <span class="emphasis"><em>using</em></span> Nix.
      Instead, we're going to walk through the Nix system to understand the fundamentals.
    </p><p>
      The first thing to note: derivations in the Nix store refer to other
      derivations which are themselves in the Nix store. They don't use <code class="literal">libc</code>
      from our system or anywhere else. It's a self-contained store of all the software we need to bootstrap up
      to any particular package.
    </p><div class="note"><h3 class="title">Note</h3><p>
      In a multi-user installation, such as the one used in NixOS,
      the store is owned by root and multiple users can install and build
      software through a Nix daemon. You can read more about multi-user
      installations here: <a class="link" href="https://nixos.org/nix/manual/#ssec-multi-user" target="_top">https://nixos.org/nix/manual/#ssec-multi-user</a>.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320797232"></a>2.2. The beginnings of the Nix store</h2></div></div></div><p>
      Start looking at the output of the install command:
    </p><pre class="screen">copying Nix to /nix/store..........................</pre><p>
      That's the <code class="filename">/nix/store</code> we
      were talking about in the first article. We're copying in the
      necessary software to bootstrap a Nix system. You can see bash,
      coreutils, the C compiler toolchain, perl libraries, sqlite and Nix itself
      with its own tools and libnix.
    </p><p>
      You may have noticed that <code class="filename">/nix/store</code> can contain
      not only directories, but also files, still always in the form
      <em class="replaceable"><code>hash-name</code></em>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320792976"></a>2.3. The Nix database</h2></div></div></div><p>
      Right after copying the store, the installation process
      initializes a database:
    </p><pre class="screen">initialising Nix database...</pre><p>
      Yes, Nix also has a database. It's stored under
      <code class="filename">/nix/var/nix/db</code>. It is a sqlite database
      that keeps track of the dependencies between derivations.
    </p><p>
      The schema is very simple: there's a table of valid paths,
      mapping from an auto increment integer to a store path.
    </p><p>
      Then there's a dependency relation from path to paths upon which they depend.
    </p><p>
      You can inspect the database by installing sqlite
      (<span class="command"><strong>nix-env -iA sqlite -f '&lt;nixpkgs&gt;'</strong></span>) and then running
      <span class="command"><strong>sqlite3 /nix/var/nix/db/db.sqlite</strong></span>.
    </p><div class="note"><h3 class="title">Note</h3><p>If this is the first time you're using Nix after the
    initial installation, remember you must close and open your
    terminals first, so that your shell environment will be updated.</p></div><div class="important"><h3 class="title">Important</h3><p>
      Never change <code class="filename">/nix/store</code> manually. If you do, then it will
      no longer be in sync with the sqlite db, unless you <span class="emphasis"><em>really</em></span>
      know what you are doing.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320785504"></a>2.4. The first profile</h2></div></div></div><p>
      Next in the installation, we encounter the concept of the <a class="link" href="https://nixos.org/nix/manual/#sec-profiles" target="_top">profile</a>:
    </p><pre class="screen">creating /home/nix/.nix-profile
installing 'nix-2.1.3'
building path(s) `/nix/store/a7p1w3z2h8pl00ywvw6icr3g5l9vm5r7-<span class="strong"><strong>user-environment</strong></span>'
created 7 symlinks in user environment</pre><p>
      A profile in Nix is a general and convenient concept for
      realizing rollbacks. Profiles are used to compose
      components that are spread among multiple paths under a new
      unified path. Not only that, but profiles are made up of multiple
      "generations": they are versioned. Whenever you change a profile,
      a new generation is created.
    </p><p>
      Generations can be switched and rolled back atomically, which makes
      them convenient for managing changes to your system.
    </p><p>
      Let's take a closer look at our profile:
    </p><pre class="screen">$ ls -l ~/.nix-profile/
bin -&gt; /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-<span class="strong"><strong>nix-2.1.3</strong></span>/bin
[...]
manifest.nix -&gt; /nix/store/q8b5238akq07lj9gfb3qb5ycq4dxxiwm-<span class="strong"><strong>env-manifest.nix</strong></span>
[...]
share -&gt; /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-<span class="strong"><strong>nix-2.1.3</strong></span>/share</pre><p>
     That <span class="package">nix-2.1.3</span> derivation in the Nix store is
     Nix itself, with binaries and libraries. The process of "installing"
     the derivation in the profile basically reproduces the hierarchy of the
     <span class="package">nix-2.1.3</span> store derivation in the profile by means of
     symbolic links.
    </p><p>
      The contents of this profile are special, because only one
      program has been installed in our profile, therefore e.g. the
      <code class="filename">bin</code> directory points to the only program
      which has been installed (Nix itself).
    </p><p>
      But that's only the contents of the latest generation of our
      profile. In fact, <code class="filename">~/.nix-profile</code> itself is a
      symbolic link to
      <code class="filename">/nix/var/nix/profiles/default</code>.
    </p><p>
      In turn, that's a symlink to <code class="filename">default-1-link</code>
      in the same directory. Yes, that means it's the first generation of
      the <code class="literal">default</code> profile.
    </p><p>
      Finally, <code class="filename">default-1-link</code> is a symlink to the nix
      store "user-environment" derivation that you saw printed during the installation process.
    </p><p>
      We'll talk about <code class="filename">manifest.nix</code> more in the next article.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320769904"></a>2.5. Nixpkgs expressions</h2></div></div></div><p>
      More output from the installer:
    </p><pre class="screen">downloading Nix expressions from `http://releases.nixos.org/nixpkgs/nixpkgs-14.10pre46060.a1a2851/nixexprs.tar.xz'...
unpacking channels...
created 2 symlinks in user environment
modifying /home/nix/.profile...
</pre><p>
      <a class="link" href="https://nixos.org/nix/manual/#chap-writing-nix-expressions" target="_top">Nix
      expressions</a> are used to describe packages and how to
      build them. <a class="link" href="https://nixos.org/nixpkgs/" target="_top">Nixpkgs</a> is the
      repository containing all of the expressions: <a class="link" href="https://github.com/NixOS/nixpkgs" target="_top">https://github.com/NixOS/nixpkgs</a>.
    </p><p>
      The installer downloaded the package descriptions from commit
      <code class="literal">a1a2851</code>.
    </p><p>
      The second profile we discover is the channels profile.
      <code class="filename">~/.nix-defexpr/channels</code> points to
      <code class="filename">/nix/var/nix/profiles/per-user/nix/channels</code>
      which points to <code class="literal">channels-1-link</code> which points
      to a Nix store directory containing the downloaded Nix
      expressions.
    </p><p>
      Channels are a set of packages and expressions available for
      download. Similar to Debian stable and unstable, there's a
      stable and unstable channel. In this installation, we're
      tracking <code class="literal">nixpkgs-unstable</code>.
    </p><p>
      Don't worry about Nix expressions yet, we'll get to them later.
    </p><p>
      Finally, for your convenience, the installer modified
      <code class="filename">~/.profile</code> to automatically enter the Nix
      environment. What
      <code class="filename">~/.nix-profile/etc/profile.d/nix.sh</code> really
      does is simply to add <code class="filename">~/.nix-profile/bin</code> to
      <code class="varname">PATH</code> and
      <code class="filename">~/.nix-defexpr/channels/nixpkgs</code> to
      <code class="varname">NIX_PATH</code>. We'll discuss
      <code class="varname">NIX_PATH</code> later.
    </p><p>
      Read <code class="filename">nix.sh</code>, it's short.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320756320"></a>2.6. FAQ: Can I change /nix to something else?</h2></div></div></div><p>
      You can, but there's a good reason to keep using
      <code class="filename">/nix</code> instead of a different directory. All
      the derivations depend on other derivations by using absolute paths. We
      saw in the first article that bash referenced a
      <span class="package">glibc</span> under a specific absolute path in <code class="filename">/nix/store</code>.
    </p><p>
      You can see for yourself, don't worry if you see multiple
      bash derivations:
    </p><pre class="screen">
$ ldd /nix/store/*bash*/bin/bash
[...]
</pre><p>
      Keeping the store in <code class="filename">/nix</code> means we can grab
      the binary cache from nixos.org (just like you grab packages
      from debian mirrors) otherwise:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="package">glibc</span> would be installed under <code class="filename">/foo/store</code>
        </p></li><li class="listitem"><p>
          Thus bash would need to point to <span class="package">glibc</span> under <code class="filename">/foo/store</code>,
          instead of under <code class="filename">/nix/store</code>
        </p></li><li class="listitem"><p>
          So the binary cache can't help, because we need a <span class="emphasis"><em>different</em></span> bash,
          and so we'd have to recompile everything ourselves.
        </p></li></ul></div><p>
    </p><p>
      After all <code class="filename">/nix</code> is a sensible place for the store.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320745792"></a>2.7. Conclusion</h2></div></div></div><p>
      We've installed Nix on our system, fully isolated and owned by
      the <code class="literal">nix</code> user as we're still coming to terms with
      this new system.
    </p><p>
      We learned some new concepts like profiles and channels. In
      particular, with profiles we're able to manage multiple
      generations of a composition of packages, while with channels
      we're able to download binaries from <code class="literal">nixos.org</code>.
    </p><p>
      The installation put everything under <code class="filename">/nix</code>,
      and some symlinks in the Nix user home. That's because every
      user is able to install and use software in her own environment.
    </p><p>
      I hope I left nothing uncovered so that you think there's
      some kind of magic going on behind the scenes. It's all
      about putting components in the store and symlinking
      these components together.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320741264"></a>2.8. Next pill...</h2></div></div></div><p>
      ...we will enter the Nix environment and learn how to interact
      with the store.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="why-you-should-give-it-a-try.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="enter-environment.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 1. Why You Should Give it a Try </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 3. Enter the Environment</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 3. Enter the Environment</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="install-on-your-running-system.html" title="Chapter 2. Install on Your Running System" /><link rel="next" href="basics-of-language.html" title="Chapter 4. The Basics of the Language" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. Enter the Environment</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="install-on-your-running-system.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="basics-of-language.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="enter-environment"></a>Chapter 3. Enter the Environment</h1></div></div></div><p>
    Welcome to the third Nix pill. In the <a class="link" href="install-on-your-running-system.html" title="Chapter 2. Install on Your Running System">second pill</a> we
    installed Nix on our running system. Now we can finally play with it a
    little, these things also apply to NixOS users.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320736432"></a>3.1. Enter the environment</h2></div></div></div><p>
      <span class="bold"><strong>If you're using NixOS, you can skip to the <a class="link" href="enter-environment.html#install-something" title="3.2. Install something">next</a> step.</strong></span>
    </p><p>
      In the previous article we created a Nix user, so let's start by switching
      to it with <span class="command"><strong>su - nix</strong></span>. If your
      <code class="filename">~/.profile</code> got evaluated, then you should now be able
      to run commands like <code class="literal">nix-env</code> and
      <code class="literal">nix-store</code>.
    </p><p>
      If that's not the case:
    </p><pre class="screen">$ source ~/.nix-profile/etc/profile.d/nix.sh
</pre><p>
      To remind you, <code class="literal">~/.nix-profile/etc</code> points to the <code class="literal">nix-2.1.3</code>
      derivation. At this point, we are in our Nix user profile.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="install-something"></a>3.2. Install something</h2></div></div></div><p>
      Finally something practical! Installation into the Nix environment is an
      interesting process. Let's install <code class="literal">hello</code>, a simple CLI
      tool which prints <code class="literal">Hello world</code> and is mainly used to test compilers
      and package installations.
    </p><p>
      Back to the installation:
    </p><pre class="screen">$ nix-env -i hello
installing 'hello-2.10'
[...]
building '/nix/store/0vqw0ssmh6y5zj48yg34gc6macr883xk-user-environment.drv'...
created 36 symlinks in user environment
</pre><p>
      Now you can run <code class="literal">hello</code>. Things to notice:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          We installed software as a user, and only for the Nix user.
        </p></li><li class="listitem"><p>
          It created a new user environment. That's a new generation of our
          Nix user profile.
        </p></li><li class="listitem"><p>
          The <a class="link" href="http://nixos.org/nix/manual/#sec-nix-env" target="_top">nix-env</a>
          tool manages environments, profiles and their generations.
        </p></li><li class="listitem"><p>
          We installed <code class="literal">hello</code> by derivation name minus the version. I repeat:
          we specified the <span class="bold"><strong>derivation name</strong></span>
          (minus the version) to install it.
        </p></li></ul></div><p>
      We can list generations without walking through the <code class="filename">/nix</code> hierarchy:
    </p><pre class="screen">$ nix-env --list-generations
   1   2014-07-24 09:23:30
   2   2014-07-25 08:45:01   (current)
</pre><p>
      Listing installed derivations:
    </p><pre class="screen">$ nix-env -q
nix-2.1.3
hello-2.10
</pre><p>
      So, where did <code class="literal">hello</code> really get installed?
      <code class="literal">which hello</code> is
      <code class="literal">~/.nix-profile/bin/hello</code> which points to the store.
      We can also list the derivation paths with <span class="command"><strong>nix-env -q --out-path</strong></span>. So
      that's what those derivation paths are called: the
      <span class="bold"><strong>output</strong></span> of a build.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320713568"></a>3.3. Path merging</h2></div></div></div><p>
      At this point you probably want to run <code class="literal">man</code> to get some documentation.
      Even if you
      already have man system-wide outside of the Nix environment, you can
      install and use it within Nix with <span class="command"><strong>nix-env -i man-db</strong></span>. As
      usual, a new generation will be created, and <code class="filename">~/.nix-profile</code> will point to
      it.
    </p><p>
      Lets inspect the <a class="link" href="http://nixos.org/nix/manual/#sec-profiles" target="_top">profile</a>
      a bit:
    </p><pre class="screen">$ ls -l ~/.nix-profile/
dr-xr-xr-x 2 nix nix 4096 Jan  1  1970 bin
lrwxrwxrwx 1 nix nix   55 Jan  1  1970 etc -&gt; /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/etc
[...]
</pre><p>
      Now that's interesting. When only <code class="literal">nix-2.1.3</code> was installed, <code class="filename">bin</code> was a
      symlink to <code class="literal">nix-2.1.3</code>. Now that we've actually installed some things
      (<code class="literal">man</code>, <code class="literal">hello</code>), it's a real directory, not a symlink.
    </p><pre class="screen">$ ls -l ~/.nix-profile/bin/
[...]
man -&gt; /nix/store/83cn9ing5sc6644h50dqzzfxcs07r2jn-man-1.6g/bin/man
[...]
nix-env -&gt; /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env
[...]
hello -&gt; /nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10/bin/hello
[...]
</pre><p>
      Okay, that's clearer now. <code class="literal">nix-env</code> merged the paths from the installed derivations.
      <span class="command"><strong>which man</strong></span> points to the Nix profile, rather than the
      system <code class="literal">man</code>, because <code class="filename">~/.nix-profile/bin</code> is at the head
      of <code class="varname">$PATH</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320703024"></a>3.4. Rolling back and switching generation</h2></div></div></div><p>
      The last command installed <code class="literal">man</code>. We should be at generation 3, unless
      you changed something in the middle. Let's say we want to rollback to the
      old generation:
    </p><pre class="screen">$ nix-env --rollback
switching from generation 3 to 2
</pre><p>
      Now <span class="command"><strong>nix-env -q</strong></span> does not list <code class="literal">man</code> anymore.
      <span class="command"><strong>ls -l `which man`</strong></span> should now be your system copy.
    </p><p>
      Enough with the rollback, let's go back to the most recent generation:
    </p><pre class="screen">$ nix-env -G 3
switching from generation 2 to 3
</pre><p>
      I invite you to read the manpage of <code class="literal">nix-env</code>. <code class="literal">nix-env</code> requires an operation
      to perform, then there are common options for all operations, as well as
      options specific to each operation.
    </p><p>
      You can of course also <a class="link" href="https://nixos.org/nix/manual/#operation-uninstall" target="_top">
      uninstall</a> and <a class="link" href="https://nixos.org/nix/manual/#operation-upgrade" target="_top">upgrade</a> packages.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320694688"></a>3.5. Querying the store</h2></div></div></div><p>
      So far we learned how to query and manipulate the environment. But all
      of the environment components point to the store.
    </p><p>
      To query and manipulate the store, there's the
      <code class="literal">nix-store</code> command. We can do some interesting things, but we'll
      only see some queries for now.
    </p><p>
      To show the direct runtime dependencies of <code class="literal">hello</code>:
    </p><pre class="screen">$ nix-store -q --references `which hello`
/nix/store/fg4yq8i8wd08xg3fy58l6q73cjy8hjr2-glibc-2.27
/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10
</pre><p>
      The argument to <code class="literal">nix-store</code> can be anything as long as it points to the
      Nix store. It will follow symlinks.
    </p><p>
      It may not make sense to you right now, but let's print reverse
      dependencies of <code class="literal">hello</code>:
    </p><pre class="screen">$ nix-store -q --referrers `which hello`
/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10
/nix/store/fhvy2550cpmjgcjcx5rzz328i0kfv3z3-env-manifest.nix
/nix/store/mp987abm20c70pl8p31ljw1r5by4xwfw-user-environment
</pre><p>
      Was it what you expected? It turns out that our environments depend upon <code class="literal">hello</code>.
      Yes, that means that the environments are in the store, and since they contain symlinks to <code class="literal">hello</code>,
      therefore the environment depends upon <code class="literal">hello</code>.
    </p><p>
      Two environments were listed, generation 2 and generation 3, since these are the ones that had
      <code class="literal">hello</code> installed in them.
    </p><p>
      The <code class="filename">manifest.nix</code> file contains metadata about the environment, such as
      which derivations are installed. So that <code class="literal">nix-env</code> can list, upgrade
      or remove them. And yet again, the current <code class="filename">manifest.nix</code> can be found at
      <code class="filename">~/.nix-profile/manifest.nix</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320683296"></a>3.6. Closures</h2></div></div></div><p>
      The closures of a derivation is a list of all its dependencies, recursively,
      including absolutely everything necessary to use that derivation.
    </p><pre class="screen">$ nix-store -qR `which man`
[...]
</pre><p>
      Copying all those derivations to the Nix store of another machine makes
      you able to run <code class="literal">man</code> out of the box on that other machine. That's the
      base of deployment using Nix, and you can already foresee the potential when
      deploying software in the cloud (hint:
      <code class="literal">nix-copy-closures</code> and
      <code class="literal">nix-store --export</code>).
    </p><p>
      A nicer view of the closure:
    </p><pre class="screen">$ nix-store -q --tree `which man`
[...]
</pre><p>
      With the above command, you can find out exactly why a
      <span class="emphasis"><em>runtime</em></span> dependency, be it direct or
      indirect, exists for a given derivation.
    </p><p>
      The same applies to environments. As an exercise, run
      <span class="command"><strong>nix-store -q --tree ~/.nix-profile</strong></span>, and see that the
      first children are direct dependencies of the user environment:
      the installed derivations, and the <code class="filename">manifest.nix</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320676160"></a>3.7. Dependency resolution</h2></div></div></div><p>
      There isn't anything like <code class="literal">apt</code> which solves a SAT problem in order to
      satisfy dependencies with lower and upper bounds on versions. There's no need
      for this because all the dependencies are static: if a derivation X depends on a derivation Y,
      then it always depends on it. A version of X which depended on Z would be a different derivation.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320674144"></a>3.8. Recovering the hard way</h2></div></div></div><pre class="screen">$ nix-env -e '*'
uninstalling 'hello-2.10'
uninstalling 'nix-2.1.3'
[...]
</pre><p>
      Oops, that uninstalled all derivations from the environment, including
      Nix. That means  we can't even run <code class="literal">nix-env</code>, what now?
    </p><p>
      Previously we got <code class="literal">nix-env</code> from the environment. Environments
      are a convenience for the user, but Nix is still there in the store!
    </p><p>
      First, pick one <code class="literal">nix-2.1.3</code> derivation:
      <span class="command"><strong>ls /nix/store/*nix-2.1.3</strong></span>, say
      <code class="filename">/nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3</code>.
    </p><p>
      The first option is to rollback:
    </p><pre class="screen">$ /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env --rollback
</pre><p>
      The second option is to install Nix, thus creating a new generation:
    </p><pre class="screen">$ /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env -i /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320667168"></a>3.9. Channels</h2></div></div></div><p>
      So where are we getting packages from? We said something about this already in the
      <a class="link" href="install-on-your-running-system.html" title="Chapter 2. Install on Your Running System">second article</a>.
      There's a list of channels from which we get packages, although usually we use a
      single channel. The tool to manage channels is
      <a class="link" href="http://nixos.org/nix/manual/#sec-nix-channel" target="_top">nix-channel</a>.
    </p><pre class="screen">$ nix-channel --list
nixpkgs http://nixos.org/channels/nixpkgs-unstable
</pre><p>
      If you're using NixOS, you may not see any output from the above command
      (if you're using the default), or you may see a channel whose
      name begins with "nixos-" instead of "nixpkgs".
    </p><p>
      That's essentially the contents of <code class="filename">~/.nix-channels</code>.
    </p><div class="note"><h3 class="title">Note</h3><p>
      <code class="filename">~/.nix-channels</code> is not a symlink to the
      nix store!
    </p></div><p>
      To update the channel run <span class="command"><strong>nix-channel --update</strong></span>.
      That will download the new Nix expressions (descriptions of the packages),
      create a new generation of the channels profile and unpack it under
      <code class="filename">~/.nix-defexpr/channels</code>.
    </p><p>
      This is quite similar to <span class="command"><strong>apt-get update</strong></span>.
      (See <a class="link" href="https://nixos.wiki/wiki/Cheatsheet" target="_top">this table</a>
      for a rough mapping between Ubuntu and NixOS package management.)
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320658128"></a>3.10. Conclusion</h2></div></div></div><p>
      We learned how to query the user environment and to manipulate it by
      installing and uninstalling software. Upgrading software is also straightforward,
      as you can read in
      <a class="link" href="https://nixos.org/nix/manual/#operation-upgrade" target="_top">the manual</a>
      (<span class="command"><strong>nix-env -u</strong></span> will upgrade all packages in the
      environment).
    </p><p>
      Everytime we change the environment, a new generation is created.
      Switching between generations is easy and immediate.
    </p><p>
      Then we learned how to query the store. We inspected the dependencies and reverse
      dependencies of store paths.
    </p><p>
      We saw how symlinks are used to compose paths from the Nix store, a useful
      trick.
    </p><p>
      A quick analogy with programming languages: you have the heap with all the
      objects, that corresponds to the Nix store. You have objects that point to other
      objects, those correspond to derivations. This is a suggestive metaphor, but will it be the right path?
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320653232"></a>3.11. Next pill</h2></div></div></div><p>
      ...we will learn the basics of the Nix language. The Nix language is used
      to describe how to build derivations, and it's the basis for everything
      else, including NixOS. Therefore it's very important to understand both the
      syntax and the semantics of the language.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="install-on-your-running-system.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="basics-of-language.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 2. Install on Your Running System </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. The Basics of the Language</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 4. The Basics of the Language</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="enter-environment.html" title="Chapter 3. Enter the Environment" /><link rel="next" href="functions-and-imports.html" title="Chapter 5. Functions and Imports" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. The Basics of the Language</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="enter-environment.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="functions-and-imports.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="basics-of-language"></a>Chapter 4. The Basics of the Language</h1></div></div></div><p>
    Welcome to the fourth Nix pill. In the
    <a class="link" href="enter-environment.html" title="Chapter 3. Enter the Environment">previous article</a> we learned about Nix
    environments. We installed software as a user, managed their profile, switched
    between generations, and queried the Nix store. Those are the very basics of
    system administration using Nix.
  </p><p>
    The
    <a class="link" href="http://nixos.org/nix/manual/#chap-writing-nix-expressions" target="_top">Nix language</a>
    is used to write expressions that produce derivations. The
    <a class="link" href="http://nixos.org/nix/manual/#sec-nix-build" target="_top">nix-build</a>
    tool is used to build derivations from an expression. Even as a system administrator that
    wants to customize the installation, it's necessary to master Nix. Using
    Nix for your jobs means you get the features we saw in the previous articles
    for free.
  </p><p>
    The syntax of Nix is quite unfamiliar, so looking at existing examples may lead you to
    think that there's a lot of magic happening. In reality, it's mostly about
    writing utility functions to make things convenient.
  </p><p>
    On the other hand, the same syntax is great for describing packages, so learning the language
    itself will pay off when writing package expressions.
  </p><div class="important"><h3 class="title">Important</h3><p>
    In Nix, everything is an expression, there are no statements. This is common in functional
    languages.
  </p></div><div class="important"><h3 class="title">Important</h3><p>
    Values in Nix are immutable.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320643536"></a>4.1. Value types</h2></div></div></div><p>
      Nix 2.0 contains a command named <span class="command"><strong>nix repl</strong></span> which is a simple command line tool
      for playing with the Nix language. In fact, Nix is a
      <a class="link" href="https://nixos.org/nix/manual/#ch-expression-language" target="_top">pure, lazy, functional language</a>,
      not only a set of tools to manage derivations. The <code class="literal">nix repl</code> syntax is slightly
      different to Nix syntax when it comes to assigning variables, but it shouldn't
      be confusing so long as you bear it in mind. I prefer to start with <code class="literal">nix repl</code>
      before cluttering your mind with more complex expressions.
    </p><p>
      Launch <code class="literal">nix repl</code>. First of all, Nix supports basic arithmetic operations:
      <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code> and <code class="literal">/</code>.
      (To exit <code class="literal">nix repl</code>, use the command <code class="literal">:q</code>.
      Help is available through the <code class="literal">:?</code> command.)
    </p><pre class="screen">nix-repl&gt; 1+3
4

nix-repl&gt; 7-4
3

nix-repl&gt; 3*2
6
</pre><p>
      Attempting to perform division in Nix can lead to some surprises.
    </p><pre class="screen">nix-repl&gt; 6/3
/home/nix/6/3
</pre><p>
      What happened? Recall that Nix is not a general purpose language, it's a
      domain-specific language for writing packages. Integer division isn't
      actually that useful when writing package expressions. Nix parsed
      <code class="literal">6/3</code> as a relative path to the current directory. To get
      Nix to perform division instead, leave a space after the
      <code class="literal">/</code>. Alternatively, you can use
      <code class="literal">builtins.div</code>.
    </p><pre class="screen">nix-repl&gt; 6/ 3
2

nix-repl&gt; builtins.div 6 3
2
</pre><p>
      Other operators are <code class="literal">||</code>, <code class="literal">&amp;&amp;</code> and <code class="literal">!</code>
      for booleans, and relational
      operators such as <code class="literal">!=</code>, <code class="literal">==</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>,
      <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>. In Nix, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>,
      <code class="literal">&lt;=</code> and <code class="literal">&gt;=</code> are not much used. There are also other operators we will see in the
      course of this series.
    </p><p>
      Nix has integer, floating point, string, path, boolean and null
      <a class="link" href="http://nixos.org/nix/manual/#ssec-values" target="_top">simple</a>
      types. Then there are also lists, sets and functions. These types are enough
      to build an operating system.
    </p><p>
      Nix is strongly typed, but it's not statically typed. That is, you
      cannot mix strings and integers, you must first do the conversion.
    </p><p>
      As demonstrated above, expressions will
      be parsed as paths as long as there's a slash not followed by a space.
      Therefore to specify the current directory, use <code class="literal">./.</code>
      In addition, Nix also parses urls specially.
    </p><p>
      Not all urls or paths can be parsed this way. If a syntax error occurs,
      it's still possible to fallback to plain strings. Literal urls and paths
      are convenient for additional safety.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320622192"></a>4.2. Identifier</h2></div></div></div><p>
      There's not much to say here, except that dash (<code class="literal">-</code>) is allowed in identifiers. That's
      convenient since many packages use dash in their names. In fact:
    </p><pre class="screen">nix-repl&gt; a-b
error: undefined variable `a-b' at (string):1:1
nix-repl&gt; a - b
error: undefined variable `a' at (string):1:1
</pre><p>
      As you can see, <code class="literal">a-b</code> is parsed as identifier, not as
      a subtraction.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320618992"></a>4.3. Strings</h2></div></div></div><p>
      It's important to understand the syntax for strings. When learning to read Nix
      expressions, you may find dollars (<code class="literal">$</code>) ambiguous, but they are very important .
      Strings are enclosed by double quotes (<code class="literal">"</code>), or two single quotes (<code class="literal">''</code>).
    </p><pre class="screen">nix-repl&gt; "foo"
"foo"
nix-repl&gt; ''foo''
"foo"
</pre><p>
      In other languages like Python you can also use single quotes for strings (e.g. <code class="literal">'foo'</code>),
      but not in Nix.
    </p><p>
      It's possible to
      <a class="link" href="http://nixos.org/nix/manual/#ssec-values" target="_top">interpolate</a>
      whole Nix expressions inside strings with the <code class="literal">${...}</code> syntax and only that syntax,
      not <code class="literal">$foo</code> or <code class="literal">{$foo}</code> or anything else.
    </p><pre class="screen">nix-repl&gt; foo = "strval"
nix-repl&gt; "$foo"
"$foo"
nix-repl&gt; "${foo}"
"strval"
nix-repl&gt; "${2+3}"
error: cannot coerce an integer to a string, at (string):1:2
</pre><p>
      Note: ignore the <code class="literal">foo = "strval"</code> assignment, special syntax in <code class="literal">nix repl</code>.
    </p><p>
      As said previously, you cannot mix integers and strings. You need to explicitly
      include conversions. We'll see this later: function calls are another story.
    </p><p>
      Using the syntax with two single quotes is useful for writing double
      quotes inside strings without needing to escape them:
    </p><pre class="screen">nix-repl&gt; ''test " test''
"test \" test"
nix-repl&gt; ''${foo}''
"strval"
</pre><p>
      Escaping <code class="literal">${...}</code> within double quoted strings is done with the backslash.
      Within two single quotes, it's done with <code class="literal">''</code>:
    </p><pre class="screen">nix-repl&gt; "\${foo}"
"${foo}"
nix-repl&gt; ''test ''${foo} test''
"test ${foo} test"
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320586480"></a>4.4. Lists</h2></div></div></div><p>
      Lists are a sequence of expressions delimited by space (<span class="emphasis"><em>not</em></span> comma):
    </p><pre class="screen">nix-repl&gt; [ 2 "foo" true (2+3) ]
[ 2 "foo" true 5 ]
</pre><p>
      Lists, like everything else in Nix, are immutable. Adding or removing
      elements from a list is possible, but will return a new list.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320583728"></a>4.5. Attribute sets</h2></div></div></div><p>
      Attribute sets are an association between string keys and a Nix values. Keys
      can only be strings. When writing attribute sets you can also use unquoted identifiers as
      keys.
    </p><pre class="screen">nix-repl&gt; s = { foo = "bar"; a-b = "baz"; "123" = "num"; }
nix-repl&gt; s
{ "123" = "num"; a-b = "baz"; foo = "bar"; }
</pre><p>
      For those reading Nix expressions from nixpkgs: do not confuse attribute sets with
      argument sets used in functions.
    </p><p>
      To access elements in the attribute set:
    </p><pre class="screen">nix-repl&gt; s.a-b
"baz"
nix-repl&gt; s."123"
"num"
</pre><p>
      Yes, you can use strings to address keys which aren't valid identifiers.
    </p><p>
      Inside an attribute set you cannot normally refer to elements of the same attribute set:
    </p><pre class="screen">nix-repl&gt; { a = 3; b = a+4; }
error: undefined variable `a' at (string):1:10
</pre><p>
      To do so, use
      <a class="link" href="https://nixos.org/nix/manual/#idm140737322044432" target="_top">recursive attribute sets</a>:
    </p><pre class="screen">nix-repl&gt; rec { a = 3; b = a+4; }
{ a = 3; b = 7; }
</pre><p>
      This is very convenient when defining packages, which tend to be recursive attribute sets.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320576640"></a>4.6. If expressions</h2></div></div></div><p>
      These are expressions, not statements.
    </p><pre class="screen">nix-repl&gt; a = 3
nix-repl&gt; b = 4
nix-repl&gt; if a &gt; b then "yes" else "no"
"no"
</pre><p>
      You can't have only the <code class="literal">then</code> branch, you must specify also the <code class="literal">else</code>
      branch, because an expression must have a value in all cases.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320573488"></a>4.7. Let expressions</h2></div></div></div><p>
      This kind of expression is used to define local variables for inner
      expressions.
    </p><pre class="screen">nix-repl&gt; let a = "foo"; in a
"foo"
</pre><p>
      The syntax is: first assign variables, then <code class="literal">in</code>, then an expression which can
      use the defined variables. The value of the whole <code class="literal">let</code> expression will be
      the value of the expression after the <code class="literal">in</code>.
    </p><pre class="screen">nix-repl&gt; let a = 3; b = 4; in a + b
7
</pre><p>
      Let's write two <code class="literal">let</code> expressions, one inside the other:
    </p><pre class="screen">nix-repl&gt; let a = 3; in let b = 4; in a + b
7
</pre><p>
      With <code class="literal">let</code> you cannot assign twice to the same variable. However, you can
      shadow outer variables:
    </p><pre class="screen">nix-repl&gt; let a = 3; a = 8; in a
error: attribute `a' at (string):1:12 already defined at (string):1:5
nix-repl&gt; let a = 3; in let a = 8; in a
8
</pre><p>
      You cannot refer to variables in a <code class="literal">let</code> expression outside of it:
    </p><pre class="screen">nix-repl&gt; let a = (let b = 3; in b); in b
error: undefined variable `b' at (string):1:31
</pre><p>
      You can refer to variables in the <code class="literal">let</code> expression when assigning variables,
      like with recursive attribute sets:
    </p><pre class="screen">nix-repl&gt; let a = 4; b = a + 5; in b
9
</pre><p>
      So beware when you want to refer to a variable from the outer scope, but
      it's also defined in the current let expression. The same applies to
      recursive attribute sets.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320563024"></a>4.8. With expression</h2></div></div></div><p>
      This kind of expression is something you rarely see in other languages.
      You can think of it like a more granular version of <code class="literal">using</code>
      from C++, or <code class="literal">from module import *</code> from Python. You decide
      per-expression when to include symbols into the scope.
    </p><pre class="screen">nix-repl&gt; longName = { a = 3; b = 4; }
nix-repl&gt; longName.a + longName.b
7
nix-repl&gt; with longName; a + b
7
</pre><p>
      That's it, it takes an attribute set and includes symbols from it in the scope of the inner
      expression. Of course, only valid identifiers from the keys of the set will be
      included. If a symbol exists in the outer scope and would also be introduced by
      the <code class="literal">with</code>, it will <span class="emphasis"><em>not</em></span> be shadowed.
      You can however still refer to the attribute set:
    </p><pre class="screen">nix-repl&gt; let a = 10; in with longName; a + b
14
nix-repl&gt; let a = 10; in with longName; longName.a + b
7
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320558048"></a>4.9. Laziness</h2></div></div></div><p>
      Nix evaluates expressions only when needed. This is a great feature when
      working with packages.
    </p><pre class="screen">nix-repl&gt; let a = builtins.div 4 0; b = 6; in b
6
</pre><p>
      Since <code class="literal">a</code> is not needed, there's no error about division by zero, because
      the expression is not in need to be evaluated. That's why we can have all
      the packages defined on demand, yet have access to specific packages very quickly.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320555152"></a>4.10. Next pill</h2></div></div></div><p>
      ...we will talk about functions and imports. In this pill I've tried to
      avoid function calls as much as possible, otherwise the post would have
      been too long.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="enter-environment.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="functions-and-imports.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Enter the Environment </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. Functions and Imports</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 5. Functions and Imports</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="basics-of-language.html" title="Chapter 4. The Basics of the Language" /><link rel="next" href="our-first-derivation.html" title="Chapter 6. Our First Derivation" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. Functions and Imports</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="basics-of-language.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="our-first-derivation.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="functions-and-imports"></a>Chapter 5. Functions and Imports</h1></div></div></div><p>
    Welcome to the fifth Nix pill. In the previous <a class="link" href="basics-of-language.html" title="Chapter 4. The Basics of the Language">fourth pill</a> we touched the Nix language
    for a moment. We introduced basic types and values of the Nix language, and
    basic expressions such as
    <code class="code">if</code>, <code class="code">with</code> and
    <code class="code">let</code>. I invite you to re-read about these expressions and play
    with them in the repl.
  </p><p>
    Functions help to build reusable components in a big repository like
    <a class="link" href="https://github.com/NixOS/nixpkgs/" target="_top">nixpkgs</a>. The Nix
    manual has a <a class="link" href="https://nixos.org/nix/manual/#ss-functions" target="_top">great explanation of
    functions</a>. Let's go: pill on one hand, Nix manual on the other hand.
  </p><p>
    I remind you how to enter the Nix environment: <code class="code">source
    ~/.nix-profile/etc/profile.d/nix.sh</code>
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320546448"></a>5.1. Nameless and single parameter</h2></div></div></div><p>
    Functions are anonymous (lambdas), and only have a single parameter. The
    syntax is extremely simple. Type the parameter name, then "<code class="code">:</code>",
    then the body of the function.
  </p><pre class="screen">nix-repl&gt; x: x*2
«lambda»</pre><p>
    So here we defined a function that takes a parameter
    <code class="code">x</code>, and returns <code class="code">x*2</code>. The problem is that we cannot
    use it in any way, because it's unnamed... joke!
  </p><p>
    We can store functions in variables.
  </p><pre class="screen">nix-repl&gt; double = x: x*2
nix-repl&gt; double
«lambda»
nix-repl&gt; double 3
6</pre><p>
    As usual, please ignore the special syntax for assignments inside <code class="literal">nix repl</code>.
    So, we defined a function <code class="code">x: x*2</code> that takes one parameter
    <code class="code">x</code>, and returns
    <code class="code">x*2</code>. This function is then assigned to the variable
    <code class="code">double</code>. Finally we did our first function call: <code class="code">double
    3</code>.
  </p><p>
    <span class="underline">Big note:</span> it's not like many other
    programming languages where you write
    <code class="code">double(3)</code>. It really is <code class="code">double 3</code>.
  </p><p>
    In summary: to call a function, name the variable, then space, then the
    argument. Nothing else to say, it's as easy as that.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320536240"></a>5.2. More than one parameter</h2></div></div></div><p>
    How do we create a function that accepts more than one parameter? For people
    not used to functional programming, this may take a while to grasp. Let's do
    it step by step.
  </p><pre class="screen">nix-repl&gt; mul = a: (b: a*b)
nix-repl&gt; mul
«lambda»
nix-repl&gt; mul 3
«lambda»
nix-repl&gt; (mul 3) 4
12</pre><p>
    We defined a function that takes the parameter <code class="code">a</code>, the body
    returns another function. This other function takes a parameter
    <code class="code">b</code> and returns <code class="code">a*b</code>. Therefore, calling <code class="code">mul
    3</code> returns this kind of function: <code class="code">b: 3*b</code>. In turn, we
    call the returned function with <code class="code">4</code>, and get the expected result.
  </p><p>
    You don't have to use parenthesis at all, Nix has sane priorities when
    parsing the code:
  </p><pre class="screen">nix-repl&gt; mul = a: b: a*b
nix-repl&gt; mul
«lambda»
nix-repl&gt; mul 3
«lambda»
nix-repl&gt; mul 3 4
12
nix-repl&gt; mul (6+7) (8+9)
221</pre><p>
    Much more readable, you don't even notice that functions only receive one
    argument. Since the argument is separated by a space, to pass more complex
    expressions you need parenthesis. In other common languages you would write
    <code class="code">mul(6+7, 8+9)</code>.
  </p><p>
    Given that functions have only one parameter, it is straightforward to use
    <span class="strong"><strong>partial application</strong></span>:
  </p><pre class="screen">nix-repl&gt; foo = mul 3
nix-repl&gt; foo 4
12
nix-repl&gt; foo 5
15</pre><p>
    We stored the function returned by <code class="code">mul 3</code> into a variable foo,
    then reused it.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320526384"></a>5.3. Arguments set</h2></div></div></div><p>
    Now this is a very cool feature of Nix. It is possible to pattern match over
    a set in the parameter. We write an alternative version of <code class="code">mul = a: b:
    a*b</code> first by using a set as argument, then using pattern matching.
  </p><pre class="screen">nix-repl&gt; mul = s: s.a*s.b
nix-repl&gt; mul { a = 3; b = 4; }
12
nix-repl&gt; mul = { a, b }: a*b
nix-repl&gt; mul { a = 3; b = 4; }
12</pre><p>
    In the first case we defined a function that accepts a single parameter. We
    then access attributes <code class="code">a</code> and
    <code class="code">b</code> from the given set. Note how the parenthesis-less syntax for
    function calls is very elegant in this case, instead of doing <code class="code">mul({
    a=3; b=4; })</code> in other languages.
  </p><p>
    In the second case we defined an arguments set. It's like defining a set,
    except without values. We require that the passed set contains the keys
    <code class="code">a</code> and <code class="code">b</code>. Then we can use those <code class="code">a</code> and
    <code class="code">b</code> in the function body directly.
  </p><pre class="screen">nix-repl&gt; mul = { a, b }: a*b
nix-repl&gt; mul { a = 3; b = 4; c = 6; }
error: anonymous function at (string):1:2 called with unexpected argument `c', at (string):1:1
nix-repl&gt; mul { a = 3; }
error: anonymous function at (string):1:2 called without required argument `b', at (string):1:1</pre><p>
    Only a set with exactly the attributes required by the function is accepted,
    nothing more, nothing less.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320518464"></a>5.4. Default and variadic attributes</h2></div></div></div><p>
    It is possible to specify <span class="strong"><strong>default values</strong></span>
    of attributes in the arguments set:
  </p><pre class="screen">nix-repl&gt; mul = { a, b ? 2 }: a*b
nix-repl&gt; mul { a = 3; }
6
nix-repl&gt; mul { a = 3; b = 4; }
12</pre><p>
    Also you can allow passing more attributes (<span class="strong"><strong>variadic</strong></span>) than the expected ones:
  </p><pre class="screen">nix-repl&gt; mul = { a, b, ... }: a*b
nix-repl&gt; mul { a = 3; b = 4; c = 2; }</pre><p>
    However, in the function body you cannot access the "c" attribute. The
    solution is to give a name to the given set with the <span class="strong"><strong>@-pattern</strong></span>:
  </p><pre class="screen">nix-repl&gt; mul = s@{ a, b, ... }: a*b*s.c
nix-repl&gt; mul { a = 3; b = 4; c = 2; }
24</pre><p>
    That's it, you give a name to the whole parameter with name@ before the set
    pattern.
  </p><p>
    Advantages of using argument sets:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
        Named unordered arguments: you don't have to remember the order of the
        arguments.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        You can pass sets, that adds a whole new layer of flexibility and
        convenience.
      </p></li></ul></div><p>
    Disadvantages:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
        Partial application does not work with argument sets. You have to
        specify the whole attribute set, not part of it.
      </p></li></ul></div><p>
    You may find similarities with <a class="link" href="https://docs.python.org/3/faq/programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" target="_top">Python
    **kwargs</a>.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320505904"></a>5.5. Imports</h2></div></div></div><p>
    The <code class="code">import</code> function is built-in and provides a way to parse a
    <code class="filename">.nix</code> file. The natural approach is to define each
    component in a <code class="filename">.nix</code> file, then compose by importing
    these files.
  </p><p>
    Let's start with the bare metal.
  </p><p>
    <code class="filename">a.nix</code>:
  </p><pre class="programlisting">3</pre><p>
    <code class="filename">b.nix</code>:
  </p><pre class="programlisting">4</pre><p>
    <code class="filename">mul.nix</code>:
  </p><pre class="programlisting">a: b: a*b</pre><pre class="screen">nix-repl&gt; a = import ./a.nix
nix-repl&gt; b = import ./b.nix
nix-repl&gt; mul = import ./mul.nix
nix-repl&gt; mul a b
12</pre><p>
    Yes it's really that simple. You import a file, and it gets parsed as
    expression. Note that the scope of the imported file does not inherit the
    scope of the importer.
  </p><p>
    <code class="filename">test.nix</code>:
  </p><pre class="programlisting">x</pre><pre class="screen">nix-repl&gt; let x = 5; in import ./test.nix
error: undefined variable `x' at /home/lethal/test.nix:1:1</pre><p>
    So how do we pass information to the module? Use functions, like we did with
    <code class="filename">mul.nix</code>. A more complex example:
  </p><p>
    <code class="filename">test.nix</code>:
  </p><pre class="programlisting">{ a, b ? 3, trueMsg ? "yes", falseMsg ? "no" }:
if a &gt; b
  then builtins.trace trueMsg true
  else builtins.trace falseMsg false
</pre><pre class="screen">nix-repl&gt; import ./test.nix { a = 5; trueMsg = "ok"; }
trace: ok
true
</pre><p>
    Explaining:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
        In <code class="filename">test.nix</code> we return a function. It accepts a set,
        with default attributes
        <code class="code">b</code>, <code class="code">trueMsg</code> and
        <code class="code">falseMsg</code>.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        <code class="code">builtins.trace</code> is a <a class="link" href="https://nixos.org/nix/manual/#ssec-builtins" target="_top">built-in
        function</a> that takes two arguments. The first is the message to
        display, the second is the value to return. It's usually used for
        debugging purposes.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        Then we import <code class="filename">test.nix</code>, and call the function with
        that set.
      </p></li></ul></div><p>
    So when is the message shown? Only when it's in need to be evaluated.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320485344"></a>5.6. Next pill</h2></div></div></div><p>
    ...we will finally write our first derivation.
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="basics-of-language.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="our-first-derivation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. The Basics of the Language </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. Our First Derivation</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 6. Our First Derivation</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="functions-and-imports.html" title="Chapter 5. Functions and Imports" /><link rel="next" href="working-derivation.html" title="Chapter 7. Working Derivation" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. Our First Derivation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="functions-and-imports.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="working-derivation.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="our-first-derivation"></a>Chapter 6. Our First Derivation</h1></div></div></div><p>
    Welcome to the sixth Nix pill. In the previous <a class="link" href="functions-and-imports.html" title="Chapter 5. Functions and Imports">fifth pill</a> we introduced functions
    and imports. Functions and imports are very simple concepts that allow for
    building complex abstractions and composition of modules to build a flexible
    Nix system.
  </p><p>
    In this post we finally arrived to writing a derivation. Derivations are the
    building blocks of a Nix system, from a file system view point. The Nix
    language is used to describe such derivations.
  </p><p>
    I remind you how to enter the Nix environment: <code class="code">source
    ~/.nix-profile/etc/profile.d/nix.sh</code>
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320478992"></a>6.1. The derivation function</h2></div></div></div><p>
    The <a class="link" href="https://nixos.org/nix/manual/#ssec-derivation" target="_top">derivation
    built-in function</a> is used to create derivations. I invite you to read
    the link in the Nix manual about the derivation built-in. A derivation from
    a Nix language view point is simply a set, with some attributes. Therefore
    you can pass the derivation around with variables like anything else.
  </p><p>
    That's where the real power comes in.
  </p><p>
    The <code class="code">derivation</code> function receives a set as first argument. This
    set requires at least the following three attributes:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
        name: the name of the derivation. In the nix store the format is
        hash-name, that's the name.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        system: is the name of the system in which the derivation can be built.
        For example, x86_64-linux.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        builder: it is the binary program that builds the derivation.
      </p></li></ul></div><p>
    First of all, what's the name of our system as seen by nix?
  </p><pre class="screen">nix-repl&gt; builtins.currentSystem
"x86_64-linux"</pre><p>
    Let's try to fake the name of the system:
  </p><pre class="screen">nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; d
«derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv»</pre><p>
    Oh oh, what's that? Did it build the derivation? No it didn't, but it
    <span class="strong"><strong>did create the .drv file</strong></span>. <code class="literal">nix repl</code> does
    not build derivations unless you tell to do so.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320468368"></a>6.2. Digression about .drv files</h2></div></div></div><p>
    What's that <code class="filename">.drv</code> file? It is the specification of how
    to build the derivation, without all the Nix language fuzz.
  </p><p>
    Before continuing, some analogies with the C language:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
        <code class="filename">.nix</code> files are like <code class="filename">.c</code> files
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        <code class="filename">.drv</code> files are intermediate files like
        <code class="filename">.o</code> files. The <code class="filename">.drv</code> describes
        how to build a derivation, it's the bare minimum information.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        out paths are then the product of the build
      </p></li></ul></div><p>
    Both drv paths and out paths are stored in the nix store as you can see.
  </p><p>
    What's in that <code class="filename">.drv</code> file? You can read it, but it's
    better to pretty print it:
  </p><pre class="screen"><code class="prompt">$ </code><strong class="userinput"><code>nix show-derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-<span class="emphasis"><em>myname.drv</em></span></code></strong>
<code class="computeroutput">{
  "/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
      }
    },
    "inputSrcs": [],
    "inputDrvs": {},
    "platform": "mysystem",
    "builder": "mybuilder",
    "args": [],
    "env": {
      "builder": "mybuilder",
      "name": "myname",
      "out": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname",
      "system": "mysystem"
    }
  }
}</code></pre><p>
    Ok we can see there's an out path, but it does not exist yet. We never told
    Nix to build it, but we know beforehand where the build output will be. Why?
  </p><p>
    Think, if Nix ever built the derivation just because we accessed it in Nix,
    we would have to wait a long time if it was, say, Firefox. That's why Nix
    let us know the path beforehand and keep evaluating the Nix expressions, but
    it's still empty because no build was ever made.
  </p><p>
    <span class="underline">Important</span>: the hash of the out path is
    based solely on the input derivations in the current version of Nix, not on
    the contents of the build product. It's possible however to have <a class="link" href="https://en.wikipedia.org/wiki/Content-addressable_storage" target="_top">content-addressable</a>
    derivations for e.g. tarballs as we'll see later on.
  </p><p>
    Many things are empty in that <code class="filename">.drv</code>, however I'll write a
    summary of the <a class="link" href="http://nixos.org/~eelco/pubs/phd-thesis.pdf" target="_top">.drv format</a>
    for you:
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        The output paths (there can be multiple ones). By default nix creates one
        out path called "out".
      </p></li><li class="listitem"><p>
        The list of input derivations. It's empty because we are not referring
        to any other derivation. Otherwise, there would be a list of other .drv
        files.
      </p></li><li class="listitem"><p>
        The system and the builder executable (yes, it's a fake one).
      </p></li><li class="listitem"><p>
        Then a list of environment variables passed to the builder.
      </p></li></ol></div><p>
    That's it, the minimum necessary information to build our derivation.
  </p><p>
    <span class="underline">Important note</span>: the environment
    variables passed to the builder are just those you see in the .drv plus some
    other Nix related configuration (number of cores, temp dir, ...). The
    builder will not inherit any variable from your running shell, otherwise
    builds would suffer from <a class="link" href="https://wiki.debian.org/ReproducibleBuilds" target="_top">non-determinism</a>.
  </p><p>
    Back to our fake derivation.
  </p><p>
    Let's build our really fake derivation:
  </p><pre class="screen">nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; :b d
[...]
these derivations will be built:
  /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
building path(s) `/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname'
error: a `mysystem' is required to build `/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv', but I am a `x86_64-linux'</pre><p>
    The <code class="code">:b</code> is a <code class="literal">nix repl</code> specific command to build a derivation.
    You can see more commands with <code class="code">:?</code> . So in the output you can
    see that it takes the <code class="filename">.drv</code> as information on how to
    build the derivation. Then it says it's trying to produce our out path.
    Finally the error we were waiting for: that derivation can't be built on our
    system.
  </p><p>
    We're doing the build inside <code class="literal">nix repl</code>, but what if we don't want to use
    <code class="literal">nix repl</code>? You can <span class="strong"><strong>realise</strong></span> a
    <code class="filename">.drv</code> with:
  </p><pre class="screen">$ nix-store -r /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv</pre><p>
    You will get the same output as before.
  </p><p>
    Let's fix the system attribute:
  </p><pre class="screen">nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = builtins.currentSystem; }
nix-repl&gt; :b d
[...]
build error: invalid file name `mybuilder'</pre><p>
    A step forward: of course, that <code class="code">mybuilder</code> executable does not
    really exist. Stop for a moment.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320435760"></a>6.3. What's in a derivation set</h2></div></div></div><p>
    It is useful to start by inspecting the return value from the derivation function.
    In this case, the returned value is a plain set:
  </p><pre class="screen">nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; builtins.isAttrs d
true
nix-repl&gt; builtins.attrNames d
[ "all" "builder" "drvAttrs" "drvPath" "name" "out" "outPath" "outputName" "system" "type" ]</pre><p>
    You can guess what <code class="code">builtins.isAttrs</code> does, it returns true if
    the argument is a set. While <code class="code">builtins.attrNames</code> returns a list
    of keys of the given set. Some kind of reflection, you might say.
  </p><p>
    Start from drvAttrs:
  </p><pre class="screen">nix-repl&gt; d.drvAttrs
{ builder = "mybuilder"; name = "myname"; system = "mysystem"; }</pre><p>
    That's basically the input we gave to the derivation function. Also
    <code class="code">d.name</code>, <code class="code">d.system</code> and <code class="code">d.builder</code>
    attributes are straight the ones we gave as input.
  </p><pre class="screen">nix-repl&gt; (d == d.out)
true</pre><p>
    So out is just the derivation itself, it seems weird but the reason is that
    we only have one output from the derivation. That's also the reason why
    <code class="code">d.all</code> is a singleton. We'll see multiple outputs later.
  </p><p>
    The <code class="code">d.drvPath</code> is the path of the <code class="filename">.drv</code>
    file: <code class="filename">/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-<span class="strong"><strong>myname.drv</strong></span></code>.
  </p><p>
    Something interesting is the <code class="code">type</code> attribute. It's
    <code class="code">"derivation"</code>. Nix does add a little of magic to sets with type
    derivation, but not that much. To let you understand, you can create
    yourself a set with that type, it's a simple set:
  </p><pre class="screen">nix-repl&gt; { type = "derivation"; }
«derivation ???»</pre><p>
    Of course it has no other information, so Nix doesn't know what to say :-)
    But you get it, the <code class="code">type = "derivation"</code> is just a convention
    for Nix and for us to understand the set is a derivation.
  </p><p>
    When writing packages, we are interested in the outputs. The other metadata
    is needed for Nix to know how to create the drv path and the out path.
  </p><p>
    The outPath attribute is the build path in the nix store:
    <code class="filename">/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-<span class="strong"><strong>myname</strong></span></code>.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320420080"></a>6.4. Referring to other derivations</h2></div></div></div><p>
    Just like dependencies in other package managers, how do we refer to other
    packages? How do we refer to other derivations in terms of files on the
    disk? We use the outPath. The outPath tells where the files are of that
    derivation. To make it more convenient, Nix is able to do a conversion from
    a derivation set to a string.
  </p><pre class="screen">nix-repl&gt; d.outPath
"/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
nix-repl&gt; builtins.toString d
"/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"</pre><p>
    Nix does the "set to string conversion" as long as there is the
    <code class="code">outPath</code> attribute (much like a toString method in other
    languages):
  </p><pre class="screen">nix-repl&gt; builtins.toString { outPath = "foo"; }
"foo"
nix-repl&gt; builtins.toString { a = "b"; }
error: cannot coerce a set to a string, at (string):1:1</pre><p>
    Say we want to use binaries from coreutils (ignore the nixpkgs etc.):
  </p><pre class="screen">nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; coreutils
«derivation /nix/store/1zcs1y4n27lqs0gw4v038i303pb89rw6-coreutils-8.21.drv»
nix-repl&gt; builtins.toString coreutils
"/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21"</pre><p>
    Apart the nixpkgs stuff, just think we added to the scope a series of
    variables. One of them is coreutils. It is the derivation of the coreutils
    package you all know of from other Linux distributions. It contains basic
    binaries for GNU/Linux systems (you may have multiple derivations of
    coreutils in the nix store, no worries):
  </p><pre class="screen">$ ls /nix/store/*coreutils*/bin
[...]</pre><p>
    I remind you, inside strings it's possible to interpolate Nix expressions
    with <code class="code">${...}</code>:
  </p><pre class="screen">nix-repl&gt; "${d}"
"/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
nix-repl&gt; "${coreutils}"
"/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21"</pre><p>
    That's very convenient, because then we could refer to e.g. the bin/true
    binary like this:
  </p><pre class="screen">nix-repl&gt; "${coreutils}/bin/true"
"/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21/bin/true"</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320411024"></a>6.5. An almost working derivation</h2></div></div></div><p>
    In the previous attempt we used a fake builder, <code class="code">mybuilder</code> which
    obviously does not exist. But we can use for example bin/true, which always
    exits with 0 (success).
  </p><pre class="screen">nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; d = derivation { name = "myname"; builder = "${coreutils}/bin/true"; system = builtins.currentSystem; }
nix-repl&gt; :b d
[...]
builder for `/nix/store/qyfrcd53wmc0v22ymhhd5r6sz5xmdc8a-myname.drv' failed to produce output path `/nix/store/ly2k1vswbfmswr33hw0kf0ccilrpisnk-myname'
</pre><p>
    Another step forward, it executed the builder (bin/true), but the builder
    did not create the out path of course, it just exited with 0.
  </p><p>
    <span class="underline">Obvious note</span>: everytime we change the
    derivation, a new hash is created.
  </p><p>
    Let's examine the new <code class="filename">.drv</code> now that we referred to
    another derivation:
  </p><pre class="screen"><code class="prompt">$ </code><strong class="userinput"><code>nix show-derivation /nix/store/qyfrcd53wmc0v22ymhhd5r6sz5xmdc8a-<span class="emphasis"><em>myname.drv</em></span></code></strong>
<code class="computeroutput">{
  "/nix/store/qyfrcd53wmc0v22ymhhd5r6sz5xmdc8a-myname.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/ly2k1vswbfmswr33hw0kf0ccilrpisnk-myname"
      }
    },
    "inputSrcs": [],
    "inputDrvs": {
      "/nix/store/hixdnzz2wp75x1jy65cysq06yl74vx7q-coreutils-8.29.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/qrxs7sabhqcr3j9ai0j0cp58zfnny0jz-coreutils-8.29/bin/true",
    "args": [],
    "env": {
      "builder": "/nix/store/qrxs7sabhqcr3j9ai0j0cp58zfnny0jz-coreutils-8.29/bin/true",
      "name": "myname",
      "out": "/nix/store/ly2k1vswbfmswr33hw0kf0ccilrpisnk-myname",
      "system": "x86_64-linux"
    }
  }
}</code></pre><p>
    Aha! Nix added a dependency to our myname.drv, it's the coreutils.drv.
    Before doing our build, Nix should build the coreutils.drv. But since
    coreutils is already in our nix store, no build is needed, it's already
    there with out path
    <code class="filename">/nix/store/qrxs7sabhqcr3j9ai0j0cp58zfnny0jz-<span class="strong"><strong>coreutils-8.29</strong></span></code>.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320402176"></a>6.6. When is the derivation built</h2></div></div></div><p>
    Nix does not build derivations <span class="strong"><strong>during
    evaluation</strong></span> of Nix expressions. In fact, that's why we have to do
    ":b drv" in <code class="literal">nix repl</code>, or use nix-store -r in the first place.
  </p><p>
    An important separation is made in Nix:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
        <span class="strong"><strong>Instantiate/Evaluation time</strong></span>: the Nix
        expression is parsed, interpreted and finally returns a derivation set.
        During evaluation, you can refer to other derivations because Nix will
        create .drv files and we will know out paths beforehand. This is
        achieved with <a class="link" href="https://nixos.org/nix/manual/#sec-nix-instantiate" target="_top">nix-instantiate</a>.
      </p></li><li class="listitem" style="list-style-type: disc"><p>
        <span class="strong"><strong>Realise/Build time</strong></span>: the .drv from the
        derivation set is built, first building .drv inputs (build
        dependencies). This is achieved with <a class="link" href="https://nixos.org/nix/manual/#rsec-nix-store-realise" target="_top">nix-store
        -r</a>.
      </p></li></ul></div><p>
    Think of it as of compile time and link time like with C/C++ projects. You
    first compile all source files to object files. Then link object files in a
    single executable.
  </p><p>
    In Nix, first the Nix expression (usually in a .nix file) is compiled to
    .drv, then each .drv is built and the product is installed in the relative
    out paths.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320392544"></a>6.7. Conclusion</h2></div></div></div><p>
    Is it that complicated to create a package for Nix? No it's not.
  </p><p>
    We're walking through the fundamentals of Nix derivations, to understand how
    they work, how they are represented. Packaging in Nix is certainly easier
    than that, but we're not there yet in this post. More Nix pills are needed.
  </p><p>
    With the derivation function we provide a set of information on how to build
    a package, and we get back the information about where the package was
    built. Nix converts a set to a string when there's an outPath, that's very
    convenient. With that, it's easy to refer to other derivations.
  </p><p>
    When Nix builds a derivation, it first creates a .drv file from a derivation
    expression, and uses it to build the output. It does so recursively for all
    the dependencies (inputs). It "executes" the .drv files like a machine. Not
    much magic after all.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320389664"></a>6.8. Next pill</h2></div></div></div><p>
    ...we will finally write our first <span class="strong"><strong>working</strong></span> derivation. Yes, this post is about "our
    first derivation", but I never said it was a working one ;)
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-and-imports.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="working-derivation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. Functions and Imports </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 7. Working Derivation</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 7. Working Derivation</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="our-first-derivation.html" title="Chapter 6. Our First Derivation" /><link rel="next" href="generic-builders.html" title="Chapter 8. Generic Builders" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 7. Working Derivation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="our-first-derivation.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="generic-builders.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="working-derivation"></a>Chapter 7. Working Derivation</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320385360"></a>7.1. Introduction</h2></div></div></div><p>
      Welcome to the seventh nix pill. In the previous
      <a class="link" href="our-first-derivation.html" title="Chapter 6. Our First Derivation">sixth pill</a> we introduced the
      notion of derivation in the Nix language — how to define a raw derivation
      and how to (try to) build it.
    </p><p>
      In this post we continue along the path, by creating a derivation that
      actually builds something. Then, we try to package a real program: we
      compile a simple C file and create a derivation out of it, given a blessed
      toolchain.
    </p><p>
      I remind you how to enter the Nix environment:
      <span class="command"><strong>source ~/.nix-profile/etc/profile.d/nix.sh</strong></span>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320381408"></a>7.2. Using a script as a builder</h2></div></div></div><p>
      What's the easiest way to run a sequence of commands for building
      something? A bash script. We write a custom bash script, and we want it to
      be our builder. Given a <code class="filename">builder.sh</code>, we want the
      derivation to run <span class="command"><strong>bash builder.sh</strong></span>.
    </p><p>
      We don't use hash bangs in <code class="filename">builder.sh</code>, because at the
      time we are writing it we do not know the path to
      <span class="application">bash</span> in the nix store. Yes, even bash is in the
      nix store, everything is there.
    </p><p>
      We don't even use <span class="application">/usr/bin/env</span>, because then we
      lose the cool stateless property of Nix. Not to mention that
      <code class="envar">PATH</code> gets cleared when building, so it wouldn't find
      <span class="application">bash</span> anyway.
    </p><p>
      In summary, we want the builder to be <span class="application">bash</span>, and
      pass it an argument, <code class="literal">builder.sh</code>. Turns out the
      <code class="function">derivation</code> function accepts an optional
      <em class="parameter"><code>args</code></em> attribute which is used to pass arguments to
      the builder executable.
    </p><p>
      First of all, let's write our <code class="filename">builder.sh</code> in the
      current directory:

      </p><pre class="programlisting">declare -xp
echo foo &gt; $out
</pre><p>

      The command <code class="literal">declare -xp</code>
      lists exported variables
      (<code class="literal">declare</code> is a builtin bash function).
      As we covered in the previous pill, Nix computes the output path of the
      derivation. The resulting <code class="literal">.drv</code> file contains a list of
      environment variables passed to the builder. One of these is
      <code class="varname">$out</code>.
    </p><p>
      What we have to do is create something in the path
      <code class="varname">$out</code>, be it a file or a directory. In this case we are
      creating a file.
    </p><p>
      In addition, we print out the environment variables during the build
      process. We cannot use <span class="application">env</span> for this, because
      <span class="application">env</span> is part of
      <span class="application">coreutils</span> and we don't have a dependency to it
      yet. We only have <span class="application">bash</span> for now.
    </p><p>
      Like for coreutils in the previous pill, we get a blessed bash for free
      from our magic nixpkgs stuff:

      </p><pre class="screen"><code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>:l &lt;nixpkgs&gt;</code></strong>
<code class="computeroutput">Added 3950 variables.</code>
<code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>"${bash}"</code></strong>
<code class="computeroutput">"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-<span class="emphasis"><em>bash-4.2-p45</em></span>"</code>
</pre><p>

      So with the usual trick, we can refer to
      <span class="application">bin/bash</span> and create our derivation:

      </p><pre class="screen"><code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>d = derivation { name = "foo"; builder = "${bash}/bin/bash"; args = [ ./builder.sh ]; system = builtins.currentSystem; }</code></strong>
<code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>:b d</code></strong>
<code class="computeroutput">these derivations will be built:
  /nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-<span class="emphasis"><em>foo.drv</em></span>
building '/nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-<span class="emphasis"><em>foo.drv</em></span>'...
declare -x HOME="/homeless-shelter"
declare -x NIX_BUILD_CORES="4"
declare -x NIX_BUILD_TOP="/tmp/nix-build-foo.drv-0"
declare -x NIX_LOG_FD="2"
declare -x NIX_STORE="/nix/store"
declare -x OLDPWD
declare -x PATH="/path-not-set"
declare -x PWD="/tmp/nix-build-foo.drv-0"
declare -x SHLVL="1"
declare -x TEMP="/tmp/nix-build-foo.drv-0"
declare -x TEMPDIR="/tmp/nix-build-foo.drv-0"
declare -x TMP="/tmp/nix-build-foo.drv-0"
declare -x TMPDIR="/tmp/nix-build-foo.drv-0"
declare -x builder="/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash"
declare -x name="foo"
declare -x out="/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo"
declare -x system="x86_64-linux"
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-<span class="emphasis"><em>foo</em></span>

this derivation produced the following outputs:
  out -&gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-<span class="emphasis"><em>foo</em></span></code></pre><p>

      We did it! The contents of
      <code class="filename">/nix/store/w024zci0x1hh1wj6gjq0jagkc1sgrf5r-<span class="emphasis"><em>foo</em></span></code>
      is really foo. We've built our first derivation.
    </p><p>
      Note that we used <code class="code">./builder.sh</code> and not
      <code class="code">"./builder.sh"</code>. This way, it is parsed as a path, and Nix
      performs some magic which we will cover later. Try using the string
      version and you will find that it cannot find
      <code class="filename">builder.sh</code>. This is because it tries to find it
      relative to the temporary build directory.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320355312"></a>7.3. The builder environment</h2></div></div></div><p>
      Let's inspect those environment variables printed during the build process.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="envar">$HOME</code> is not your home directory, and
          <code class="filename">/homeless-shelter</code> doesn't exist at all. We force
          packages not to depend on <code class="envar">$HOME</code> during the build
          process.
        </p></li><li class="listitem"><p>
          <code class="envar">$PATH</code> plays the same game as <code class="envar">$HOME</code>
        </p></li><li class="listitem"><p>
          <code class="envar">$NIX_BUILD_CORES</code> and <code class="envar">$NIX_STORE</code> are
          <a class="link" href="http://nixos.org/nix/manual/#sec-conf-file" target="_top">nix
          configuration options</a>
        </p></li><li class="listitem"><p>
          <code class="envar">$PWD</code> and <code class="envar">$TMP</code> clearly show that nix
          created a temporary build directory
        </p></li><li class="listitem"><p>
          Then <code class="envar">$builder</code>, <code class="envar">$name</code>,
          <code class="envar">$out</code>, and <code class="envar">$system</code> are variables set due
          to the .drv file's contents.
        </p></li></ul></div><p>
    </p><p>
      And that's how we were able to use <code class="envar">$out</code> in our derivation
      and put stuff in it. It's like Nix reserved a slot in the nix store for
      us, and we must fill it.
    </p><p>

      In terms of autotools, <code class="envar">$out</code> will be the
      <code class="option">--prefix</code> path. Yes, not the make
      <code class="option">DESTDIR</code>, but the <code class="option">--prefix</code>. That's the
      essence of stateless packaging. You don't install the package in a global
      common path under <code class="filename">/</code>, you install it in a local
      isolated path under your nix store slot.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320339776"></a>7.4. The .drv contents</h2></div></div></div><p>
      We added something else to the derivation this time: the args attribute.
      Let's see how this changed the .drv compared to the previous pill:
      </p><pre class="screen"><code class="prompt">$ </code><strong class="userinput"><code>nix show-derivation /nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-<span class="emphasis"><em>foo.drv</em></span></code></strong>
<code class="computeroutput">{
  "/nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo"
      }
    },
    "inputSrcs": [
      "/nix/store/lb0n38r2b20r8rl1k45a7s4pj6ny22f7-builder.sh"
    ],
    "inputDrvs": {
      "/nix/store/hcgwbx42mcxr7ksnv0i1fg7kw6jvxshb-bash-4.4-p19.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
    "args": [
      "/nix/store/lb0n38r2b20r8rl1k45a7s4pj6ny22f7-builder.sh"
    ],
    "env": {
      "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
      "name": "foo",
      "out": "/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo",
      "system": "x86_64-linux"
    }
  }
}</code></pre><p>

      Much like the usual .drv, except that there's a list of arguments in there
      passed to the builder (<span class="application">bash</span>) with
      <code class="filename">builder.sh</code>… In the nix store..? Nix automatically
      copies files or directories needed for the build into the store to ensure
      that they are not changed during the build process and that the deployment
      is stateless and independent of the building machine.
      <code class="filename">builder.sh</code> is not only in the arguments passed to the
      builder, it's also in the input derivations.
    </p><p>
      Given that <code class="filename">builder.sh</code> is a plain file, it has no .drv
      associated with it. The store path is computed based on the filename and
      on the hash of its contents. Store paths are covered in detail in <a class="link" href="nix-store-paths.html" title="Chapter 18. Nix Store Paths">a later pill</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320331952"></a>7.5. Packaging a simple C program</h2></div></div></div><p>
      Start off by writing a simple C program called <code class="filename">simple.c</code>:

      </p><pre class="programlisting">void main() {
  puts("Simple!");
}
</pre><p>

      And its <code class="filename">simple_builder.sh</code>:

      </p><pre class="programlisting">export PATH="$coreutils/bin:$gcc/bin"
mkdir $out
gcc -o $out/simple $src
</pre><p>

      Don't worry too much about where those variables come from yet; let's
      write the derivation and build it:

      </p><pre class="screen"><code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>:l &lt;nixpkgs&gt;</code></strong>
<code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>simple = derivation { name = "simple"; builder = "${bash}/bin/bash"; args = [ ./simple_builder.sh ]; gcc = gcc; coreutils = coreutils; src = ./simple.c; system = builtins.currentSystem; }</code></strong>
<code class="prompt">nix-repl&gt; </code><strong class="userinput"><code>:b simple</code></strong>
<code class="computeroutput">this derivation produced the following outputs:

  out -&gt; /nix/store/ni66p4jfqksbmsl616llx3fbs1d232d4-simple
</code></pre><p>

      Now you can run
      <code class="filename">/nix/store/ni66p4jfqksbmsl616llx3fbs1d232d4-simple/simple</code>
      in your shell.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320324800"></a>7.6. Explanation</h2></div></div></div><p>
      We added two new attributes to the derivation call, <code class="varname">gcc</code>
      and <code class="varname">coreutils</code>. In <code class="code">gcc = gcc;</code>, the name on
      the left is the name in the derivation set, and the name on the right
      refers to the gcc derivation from nixpkgs. The same applies for coreutils.
    </p><p>
      We also added the <code class="varname">src</code> attribute, nothing magical — it's
      just a name, to which the path <code class="filename">./simple.c</code> is
      assigned. Like <code class="filename">simple-builder.sh</code>,
      <code class="filename">simple.c</code> will be added to the store.
    </p><p>
      The trick: every attribute in the set passed to
      <code class="function">derivation</code> will be converted to a string and passed
      to the builder as an environment variable. This is how the builder gains
      access to <span class="application">coreutils</span> and
      <span class="application">gcc</span>: when converted to strings, the derivations
      evaluate to their output paths, and appending <code class="literal">/bin</code> to
      these leads us to their binaries.
    </p><p>
      The same goes for the <code class="varname">src</code> variable. <code class="envar">$src</code>
      is the path to <code class="filename">simple.c</code> in the nix store. As an
      exercise, pretty print the .drv file. You'll see
      <code class="filename">simple_builder.sh</code> and <code class="filename">simple.c</code>
      listed in the input derivations, along with
      <span class="application">bash</span>, <span class="application">gcc</span> and
      <span class="application">coreutils</span> .drv files. The newly added
      environment variables described above will also appear.
    </p><p>
      In <code class="filename">simple_builder.sh</code> we set the <code class="envar">PATH</code>
      for <span class="application">gcc</span> and
      <span class="application">coreutils</span> binaries, so that our build script
      can find the necessary utilities like <span class="application">mkdir</span> and
      <span class="application">gcc</span>.
    </p><p>
      We then create <code class="envar">$out</code> as a directory and place the binary
      inside it. Note that <span class="application">gcc</span> is found via the
      <code class="envar">PATH</code> environment variable, but it could equivalently be
      referenced explicitly using <code class="code">$gcc/bin/gcc</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320307760"></a>7.7. Enough of <code class="literal">nix repl</code></h2></div></div></div><p>
      Drop out of <span class="application">nix repl</span> and write a file
      <code class="filename">simple.nix</code>:

      </p><pre class="programlisting">with (import &lt;nixpkgs&gt; {});
derivation {
  name = "simple";
  builder = "${bash}/bin/bash";
  args = [ ./simple_builder.sh ];
  inherit gcc coreutils;
  src = ./simple.c;
  system = builtins.currentSystem;
}
</pre><p>

      Now you can build it with <span class="command"><strong>nix-build simple.nix</strong></span>. This
      will create a symlink <code class="filename">result</code> in the current
      directory, pointing to the out path of the derivation.
    </p><p>
      <span class="application">nix-build</span> does two jobs:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="http://nixos.org/nix/manual/#sec-nix-instantiate" target="_top">
            <span class="application">nix-instantiate</span>
          </a>: parse and evaluate <code class="filename">simple.nix</code> and return
          the .drv file corresponding to the parsed derivation set
        </p></li><li class="listitem"><p>
            <a class="link" href="http://nixos.org/nix/manual/#rsec-nix-store-realise" target="_top">
              <span class="command"><strong>nix-store -r</strong></span>
            </a>: realise the .drv file, which actually builds it.
        </p></li></ul></div><p>
      Finally, it creates the symlink.
    </p><p>
      In the first line of <code class="filename">simple.nix</code>, we have an
      <code class="function">import</code> function call nested in a <code class="code">with</code>
      statement. Recall that <code class="function">import</code> accepts one argument, a
      nix file to load. In this case, the contents of the file evaluated to a
      function.
    </p><p>
      Afterwards, we call the function with the empty set. We saw this already
      in <a class="link" href="functions-and-imports.html" title="Chapter 5. Functions and Imports">the fifth pill</a>. To
      reiterate: <code class="code">import &lt;nixpkgs&gt; {}</code> is calling two functions,
      not one. Reading it as <code class="code">(import &lt;nixpkgs&gt;) {}</code> makes this
      clearer.
    </p><p>
      The value returned by the nixpkgs function is a set. More specifically,
      it's a set of derivations. Using the <code class="code">with</code> expression we bring
      them into scope. This is equivalent to the <span class="command"><strong>:l &lt;nixpkgs&gt;</strong></span>
      we used in <span class="application">nix repl</span>; it allows us to easily access derivations
      such as <code class="varname">bash</code>, <code class="varname">gcc</code>, and
      <code class="varname">coreutils</code>.
    </p><p>
      Then we meet the
      <a class="link" href="https://nixos.org/nix/manual/#idm140737322036688" target="_top"><code class="code">inherit</code> keyword</a>.
      <code class="code">inherit foo;</code> is equivalent to <code class="code">foo = foo;</code>.
      Similarly, <code class="code">inherit foo bar;</code> is equivalent to <code class="code">foo = foo; bar = bar;</code>.
    </p><p>
      This syntax only makes sense inside sets. There's no magic involved, it's
      simply a convenience to avoid repeating the same name for both the
      attribute name and the value in scope.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320286608"></a>7.8. Next pill</h2></div></div></div><p>
      We will generalize the builder. You may have noticed that we wrote two
      separate <code class="filename">builder.sh</code> scripts in this post. We would
      like to have a generic builder script instead, especially since each build
      script goes in the nix store: a bit of a waste.
    </p><p>
      <span class="emphasis"><em>Is it really that hard to package stuff in Nix? No</em></span>,
      here we're studying the fundamentals of Nix.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="our-first-derivation.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="generic-builders.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 6. Our First Derivation </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 8. Generic Builders</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 8. Generic Builders</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="working-derivation.html" title="Chapter 7. Working Derivation" /><link rel="next" href="automatic-runtime-dependencies.html" title="Chapter 9. Automatic Runtime Dependencies" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 8. Generic Builders</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="working-derivation.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="automatic-runtime-dependencies.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="generic-builders"></a>Chapter 8. Generic Builders</h1></div></div></div><p>
    Welcome to the 8th Nix pill. In the previous
    <a class="link" href="working-derivation.html" title="Chapter 7. Working Derivation">7th pill</a> we successfully built a
    derivation. We wrote a builder script that compiled a C file and installed
    the binary under the nix store.
  </p><p>
    In this post, we will generalize the builder script, write a Nix expression
    for <a class="link" href="http://www.gnu.org/software/hello/" target="_top">GNU hello world</a>
    and create a wrapper around the derivation built-in function.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320279024"></a>8.1. Packaging GNU hello world</h2></div></div></div><p>
      In the previous pill we packaged a simple .c file, which was being
      compiled with a raw gcc call. That's not a good example of a project. Many
      use autotools, and since we're going to generalize our builder, it would
      be better do it with the most used build system.
    </p><p>
      <a class="link" href="http://www.gnu.org/software/hello/" target="_top">GNU hello world</a>,
      despite its name, is a simple yet complete project which uses autotools.
      Fetch the latest tarball here:
      <a class="link" href="http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz" target="_top">http://ftp.gnu.org/gnu/hello/hello-2.10.tar.gz</a>.
    </p><p>
      Let's create a builder script for GNU hello world, hello_builder.sh:
    </p><pre class="screen">export PATH="$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$binutils/bin"
tar -xzf $src
cd hello-2.10
./configure --prefix=$out
make
make install
</pre><p>
      And the derivation hello.nix:
    </p><pre class="screen">with (import &lt;nixpkgs&gt; {});
derivation {
  name = "hello";
  builder = "${bash}/bin/bash";
  args = [ ./hello_builder.sh ];
  inherit gnutar gzip gnumake gcc coreutils gawk gnused gnugrep;
  binutils = binutils-unwrapped;
  src = ./hello-2.10.tar.gz;
  system = builtins.currentSystem;
}
</pre><div class="note"><h3 class="title">Nix on darwin</h3><p>Darwin (i.e. macOS) builds typically use <code class="literal">clang</code> rather than <code class="literal">gcc</code> for a C compiler.
    We can adapt this early example for darwin by using this modified version of <code class="filename">hello.nix</code>:
    </p><pre class="screen">with (import &lt;nixpkgs&gt; {});
derivation {
  name = "hello";
  builder = "${bash}/bin/bash";
  args = [ ./hello_builder.sh ];
  inherit gnutar gzip gnumake coreutils gawk gnused gnugrep;
  gcc = clang;
  binutils = clang.bintools.bintools_bin;
  src = ./hello-2.10.tar.gz;
  system = builtins.currentSystem;
}
</pre><p>
    Later, we will show how Nix can automatically handle these differences.
    For now, please be just aware that changes similar to the above may be needed in what follows.
    </p></div><p>
      Now build it with <span class="command"><strong>nix-build hello.nix</strong></span> and you can
      launch <code class="filename">result/bin/hello</code>. Nothing easier, but do we
      have to create a builder.sh for each package? Do we always have to pass
      the dependencies to the <code class="literal">derivation</code> function?
    </p><p>
      Please note the <span class="command"><strong>--prefix=$out</strong></span> we were talking about in
      the <a class="link" href="working-derivation.html" title="Chapter 7. Working Derivation">previous pill</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320265840"></a>8.2. A generic builder</h2></div></div></div><p>
      Let's create a generic <code class="filename">builder.sh</code> for autotools
      projects:
    </p><pre class="screen">set -e
unset PATH
for p in $buildInputs; do
  export PATH=$p/bin${PATH:+:}$PATH
done

tar -xf $src

for d in *; do
  if [ -d "$d" ]; then
    cd "$d"
    break
  fi
done

./configure --prefix=$out
make
make install
</pre><p>
      What do we do here?
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          Exit the build on any error with <span class="command"><strong>set -e</strong></span>.
        </p></li><li class="listitem"><p>
          First <span class="command"><strong>unset PATH</strong></span>, because it's initially set to a
          non-existant path.
        </p></li><li class="listitem"><p>
          We'll see this below in detail, however for each path in
          <code class="code">$buildInputs</code>, we append <code class="code">bin</code> to
          <code class="code">PATH</code>.
        </p></li><li class="listitem"><p>
          Unpack the source.
        </p></li><li class="listitem"><p>
          Find a directory where the source has been unpacked and
          <span class="command"><strong>cd</strong></span> into it.
        </p></li><li class="listitem"><p>
          Once we're set up, compile and install.
        </p></li></ol></div><p>
      As you can see, there's no reference to "hello" in the builder anymore.
      It still does several assumptions, but it's certainly more generic.
    </p><p>
      Now let's rewrite <code class="filename">hello.nix</code>:
    </p><pre class="screen">with (import &lt;nixpkgs&gt; {});
derivation {
  name = "hello";
  builder = "${bash}/bin/bash";
  args = [ ./builder.sh ];
  buildInputs = [ gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep ];
  src = ./hello-2.10.tar.gz;
  system = builtins.currentSystem;
}
</pre><p>
      All clear, except that buildInputs. However it's easier than any black
      magic you are thinking in this moment.
    </p><p>
      Nix is able to convert a list to a string. It first converts the elements
      to strings, and then concatenates them separated by a space:
    </p><pre class="screen">nix-repl&gt; builtins.toString 123
"123"
nix-repl&gt; builtins.toString [ 123 456 ]
"123 456"
</pre><p>
      Recall that derivations can be converted to a string, hence:
    </p><pre class="screen">nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; builtins.toString gnugrep
"/nix/store/g5gdylclfh6d224kqh9sja290pk186xd-gnugrep-2.14"
nix-repl&gt; builtins.toString [ gnugrep gnused ]
"/nix/store/g5gdylclfh6d224kqh9sja290pk186xd-gnugrep-2.14 /nix/store/krgdc4sknzpw8iyk9p20lhqfd52kjmg0-gnused-4.2.2"
</pre><p>
      Simple! The buildInputs variable is a string with out paths separated by
      space, perfect for bash usage in a for loop.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320249200"></a>8.3. A more convenient derivation function</h2></div></div></div><p>
      We managed to write a builder that can be used for multiple autotools
      projects. But in the hello.nix expression we are specifying tools that
      are common to more projects; we don't want to pass them everytime.
    </p><p>
      A natural approach would be to create a function that accepts an
      attribute set, similar to the one used by the derivation function, and
      merge it with another attribute set containing values common to many
      projects.
    </p><p>
      Create <code class="filename">autotools.nix</code>:
    </p><pre class="screen">pkgs: attrs:
  with pkgs;
  let defaultAttrs = {
    builder = "${bash}/bin/bash";
    args = [ ./builder.sh ];
    baseInputs = [ gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep ];
    buildInputs = [];
    system = builtins.currentSystem;
  };
  in
  derivation (defaultAttrs // attrs)
</pre><p>
      Ok now we have to remember a little about
      <a class="link" href="functions-and-imports.html" title="Chapter 5. Functions and Imports">Nix functions</a>. The whole nix
      expression of this <code class="filename">autotools.nix</code> file will evaluate
      to a function. This function accepts a parameter <code class="code">pkgs</code>, then
      returns a function which accepts a parameter <code class="code">attrs</code>.
    </p><p>
      The body of the function is simple, yet at first sight it might be hard
      to grasp:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          First drop in the scope the magic <code class="code">pkgs</code> attribute set.
        </p></li><li class="listitem"><p>
          Within a let expression we define a helper variable,
          <code class="code">defaultAttrs</code>, which serves as a set of common attributes
          used in derivations.
        </p></li><li class="listitem"><p>
          Finally we create the derivation with that strange expression,
          (<code class="code">defaultAttrs // attrs</code>).
        </p></li></ol></div><p>
      The
      <a class="link" href="https://nixos.org/manual/nix/stable/#sec-language-operators" target="_top">// operator</a>
      is an operator between two sets. The result is the union of the two sets.
      In case of conflicts between attribute names, the value on the right set
      is preferred.
    </p><p>
      So we use <code class="code">defaultAttrs</code> as base set, and add (or override) the
      attributes from <code class="code">attrs</code>.
    </p><p>
      A couple of examples ought to be enough to clear out the behavior of the
      operator:
    </p><pre class="screen">nix-repl&gt; { a = "b"; } // { c = "d"; }
{ a = "b"; c = "d"; }
nix-repl&gt; { a = "b"; } // { a = "c"; }
{ a = "c"; }
</pre><p>
      <span class="bold"><strong>Exercise:</strong></span>
      Complete the new <code class="filename">builder.sh</code> by adding
      <code class="code">$baseInputs</code> in the <code class="code">for</code> loop together with
      <code class="code">$buildInputs</code>. As you noticed, we passed that new variable in
      the derivation. Instead of merging buildInputs with the base ones, we
      prefer to preserve buildInputs as seen by the caller, so we keep them
      separated. Just a matter of choice.
    </p><p>
      Then we rewrite <code class="filename">hello.nix</code> as follows:
    </p><pre class="screen">let
  pkgs = import &lt;nixpkgs&gt; {};
  mkDerivation = import ./autotools.nix pkgs;
in mkDerivation {
  name = "hello";
  src = ./hello-2.10.tar.gz;
}
</pre><p>
      Finally! We got a very simple description of a package! Below are a
      couple of remarks that you may find useful as you're continuing to
      understand the nix language:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          We assigned to pkgs the import that we did in the previous expressions
          in the "with". Don't be afraid, it's that straightforward.
        </p></li><li class="listitem"><p>
          The mkDerivation variable is a nice example of partial application,
          look at it as (<code class="code">import ./autotools.nix</code>) <code class="code">pkgs</code>.
          First we import the expression, then we apply the <code class="code">pkgs</code>
          parameter. That will give us a function that accepts the attribute
          set <code class="code">attrs</code>.
        </p></li><li class="listitem"><p>
          We create the derivation specifying only name and src. If the project
          eventually needed other dependencies to be in PATH, then we would
          simply add those to buildInputs (not specified in hello.nix because
          empty).
        </p></li></ul></div><p>
      Note we didn't use any other library. Special C flags may be needed to
      find include files of other libraries at compile time, and ld flags at
      link time.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320223216"></a>8.4. Conclusion</h2></div></div></div><p>
      Nix gives us the bare metal tools for creating derivations, setting up a
      build environment and storing the result in the nix store.
    </p><p>
      Out of this pill we managed to create a generic builder for autotools
      projects, and a function <code class="code">mkDerivation</code> that composes by default
      the common components used in autotools projects instead of repeating them
      in all the packages we would write.
    </p><p>
      We are familiarizing ourselves with the way a Nix system grows up: it's
      about creating and composing derivations with the Nix language.
    </p><p>
      <span class="underline">Analogy</span>: in C you create objects
      in the heap, and then you compose them inside new objects. Pointers are
      used to refer to other objects.
    </p><p>
      In Nix you create derivations stored in the nix store, and then you
      compose them by creating new derivations. Store paths are used to refer
      to other derivations.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320218384"></a>8.5. Next pill</h2></div></div></div><p>
      ...we will talk a little about runtime dependencies. Is the GNU hello
      world package self-contained? What are its runtime dependencies? We only
      specified build dependencies by means of using other derivations in the
      "hello" derivation.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="working-derivation.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="automatic-runtime-dependencies.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 7. Working Derivation </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 9. Automatic Runtime Dependencies</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 9. Automatic Runtime Dependencies</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="generic-builders.html" title="Chapter 8. Generic Builders" /><link rel="next" href="developing-with-nix-shell.html" title="Chapter 10. Developing with nix-shell" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 9. Automatic Runtime Dependencies</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="generic-builders.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="developing-with-nix-shell.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="automatic-runtime-dependencies"></a>Chapter 9. Automatic Runtime Dependencies</h1></div></div></div><p>
    Welcome to the 9th Nix pill. In the previous
    <a class="link" href="generic-builders.html" title="Chapter 8. Generic Builders">8th pill</a> we wrote a generic builder
    for autotools projects. We feed build dependencies, a source tarball, and
    we get a Nix derivation as a result.
  </p><p>
    Today we stop by the GNU hello world program to analyze build and runtime
    dependencies, and enhance the builder in order to avoid unnecessary runtime
    dependencies.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320212800"></a>9.1. Build dependencies</h2></div></div></div><p>
      Let's start analyzing build dependencies for our GNU hello world package:
    </p><pre class="screen">$ nix-instantiate hello.nix
/nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
$ nix-store -q --references /nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
/nix/store/0q6pfasdma4as22kyaknk4kwx4h58480-hello-2.10.tar.gz
/nix/store/1zcs1y4n27lqs0gw4v038i303pb89rw6-coreutils-8.21.drv
/nix/store/2h4b30hlfw4fhqx10wwi71mpim4wr877-gnused-4.2.2.drv
/nix/store/39bgdjissw9gyi4y5j9wanf4dbjpbl07-gnutar-1.27.1.drv
/nix/store/7qa70nay0if4x291rsjr7h9lfl6pl7b1-builder.sh
/nix/store/g6a0shr58qvx2vi6815acgp9lnfh9yy8-gnugrep-2.14.drv
/nix/store/jdggv3q1sb15140qdx0apvyrps41m4lr-bash-4.2-p45.drv
/nix/store/pglhiyp1zdbmax4cglkpz98nspfgbnwr-gnumake-3.82.drv
/nix/store/q9l257jn9lndbi3r9ksnvf4dr8cwxzk7-gawk-4.1.0.drv
/nix/store/rgyrqxz1ilv90r01zxl0sq5nq0cq7v3v-binutils-2.23.1.drv
/nix/store/qzxhby795niy6wlagfpbja27dgsz43xk-gcc-wrapper-4.8.3.drv
/nix/store/sk590g7fv53m3zp0ycnxsc41snc2kdhp-gzip-1.6.drv
</pre><p>
      It has exactly the derivations referenced in the <code class="code">derivation</code>
      function, nothing more, nothing less. Some of them might not be used at
      all, however given that our generic mkDerivation function always pulls
      such dependencies (think of it like
      <a class="link" href="https://packages.debian.org/unstable/build-essential" target="_top">build-essential</a>
      of Debian), for every package you build from now on, you will have these
      packages in the nix store.
    </p><p>
      Why are we looking at .drv files? Because the hello.drv file is the
      representation of the build action to perform in order to build the hello
      out path, and as such it also contains the input derivations needed to be
      built before building hello.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320208608"></a>9.2. Digression about NAR files</h2></div></div></div><p>
      NAR is the Nix ARchive. First question: why not tar? Why another archiver?
      Because commonly used archivers are not deterministic. They add padding,
      they do not sort files, they add timestamps, etc.. Hence NAR, a very
      simple deterministic archive format being used by Nix for deployment.
      NARs are also used extensively within Nix itself as we'll see below.
    </p><p>
      For the rationale and implementation details you can find more in the
      <a class="link" href="http://nixos.org/~eelco/pubs/phd-thesis.pdf" target="_top">Dolstra's PhD Thesis</a>.
    </p><p>
      To create NAR archives, it's possible to use
      <span class="command"><strong>nix-store --dump</strong></span> and
      <span class="command"><strong>nix-store --restore</strong></span>. Those two commands work
      regardless of <code class="filename">/nix/store</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320203936"></a>9.3. Runtime dependencies</h2></div></div></div><p>
      Something is different for runtime dependencies however. Build
      dependencies are automatically recognized by Nix once they are used in
      any <code class="code">derivation</code> call, but we never specify what are the
      runtime dependencies for a derivation.
    </p><p>
      There's really black magic involved. It's something that at first glance
      makes you think "no, this can't work in the long term", but at the same
      it works so well that a whole operating system is built on top of this
      magic.
    </p><p>
      In other words, Nix automatically computes all the runtime dependencies
      of a derivation, and it's possible thanks to the hash of the store paths.
    </p><p>
      Steps:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          Dump the derivation as NAR, a serialization of the derivation output.
          Works fine whether it's a single file or a directory.
        </p></li><li class="listitem"><p>
          For each build dependency .drv and its relative out path, search the
          contents of the NAR for this out path.
        </p></li><li class="listitem"><p>
          If found, then it's a runtime dependency.
        </p></li></ol></div><p>
      You get really all the runtime dependencies, and that's why Nix
      deployments are so easy.
    </p><pre class="screen">$ nix-instantiate hello.nix
/nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
$ nix-store -r /nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
/nix/store/a42k52zwv6idmf50r9lps1nzwq9khvpf-hello
$ nix-store -q --references /nix/store/a42k52zwv6idmf50r9lps1nzwq9khvpf-hello
/nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19
/nix/store/8jm0wksask7cpf85miyakihyfch1y21q-gcc-4.8.3
/nix/store/a42k52zwv6idmf50r9lps1nzwq9khvpf-hello
</pre><p>
      Ok glibc and gcc. Well, gcc really should not be a runtime dependency!
    </p><pre class="screen">$ strings result/bin/hello|grep gcc
/nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib:/nix/store/8jm0wksask7cpf85miyakihyfch1y21q-gcc-4.8.3/lib64
</pre><p>
      Oh Nix added gcc because its out path is mentioned in the "hello" binary.
      Why is that? That's the
      <a class="link" href="http://en.wikipedia.org/wiki/Rpath" target="_top">ld rpath</a>.
      It's the list of directories where libraries can be found at runtime. In
      other distributions, this is usually not abused. But in Nix, we have to
      refer to particular versions of libraries, thus the rpath has an
      important role.
    </p><p>
      The build process adds that gcc lib path thinking it may be useful at
      runtime, but really it's not. How do we get rid of it? Nix authors have
      written another magical tool called
      <a class="link" href="https://nixos.org/patchelf.html" target="_top">patchelf</a>, which
      is able to reduce the rpath to the paths that are really used by the
      binary.
    </p><p>
      Even after reducing the rpath, the hello binary would still
      depend upon gcc because of some debugging information. This
      unnecesarily increases the size of our runtime
      dependencies. We'll explore how <span class="command"><strong><a class="link" href="https://linux.die.net/man/1/strip" target="_top">strip</a>
      </strong></span> can help us with that in the next section.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320190816"></a>9.4. Another phase in the builder</h2></div></div></div><p>
      We will add a new phase to our autotools builder. The builder has these
      phases already:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          First the environment is set up
        </p></li><li class="listitem"><p>
          Unpack phase: we unpack the sources in the current directory
          (remember, Nix changes dir to a temporary directory first)
        </p></li><li class="listitem"><p>
          Change source root to the directory that has been unpacked
        </p></li><li class="listitem"><p>
          Configure phase: <span class="command"><strong>./configure</strong></span>
        </p></li><li class="listitem"><p>
          Build phase: <span class="command"><strong>make</strong></span>
        </p></li><li class="listitem"><p>
          Install phase: <span class="command"><strong>make install</strong></span>
        </p></li></ol></div><p>
      We add a new phase after the installation phase, which we call
      <span class="bold"><strong>fixup</strong></span> phase. At the end of the
      <code class="filename">builder.sh</code> follows:
    </p><pre class="screen">find $out -type f -exec patchelf --shrink-rpath '{}' \; -exec strip '{}' \; 2&gt;/dev/null
</pre><p>
      That is, for each file we run <span class="command"><strong>patchelf --shrink-rpath</strong></span>
      and <span class="command"><strong>strip</strong></span>. Note that we used two new commands here,
      <span class="command"><strong>find</strong></span> and <span class="command"><strong>patchelf</strong></span>.
      <span class="bold"><strong>Exercise:</strong></span> These two
      deserve a place in <code class="code">baseInputs</code> of
      <code class="filename">autotools.nix</code> as <span class="command"><strong>findutils</strong></span> and
      <span class="command"><strong>patchelf</strong></span>.
    </p><p>
      Rebuild <code class="filename">hello.nix</code> and...:
    </p><pre class="screen">$ nix-build hello.nix
[...]
$ nix-store -q --references result
/nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19
/nix/store/md4a3zv0ipqzsybhjb8ndjhhga1dj88x-hello
</pre><p>
      ...only glibc is the runtime dependency. Exactly what we wanted.
    </p><p>
      The package is self-contained, copy its closure on another machine and
      you will be able to run it. Remember, only a very few components under
      the <code class="filename">/nix/store</code> are required to
      <a class="link" href="install-on-your-running-system.html" title="Chapter 2. Install on Your Running System">run nix</a>.
      The hello binary will use that exact version of glibc library and
      interpreter, not the system one:
    </p><pre class="screen">$ ldd result/bin/hello
 linux-vdso.so.1 (0x00007fff11294000)
 libc.so.6 =&gt; /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/libc.so.6 (0x00007f7ab7362000)
 /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/ld-linux-x86-64.so.2 (0x00007f7ab770f000)
</pre><p>
      Of course, the executable runs fine as long as everything is under the
      <code class="filename">/nix/store</code> path.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320170000"></a>9.5. Conclusion</h2></div></div></div><p>
      Short post compared to previous ones as I'm still on vacation, but I hope
      you enjoyed it. Nix provides tools with cool features. In particular, Nix
      is able to compute all runtime dependencies automatically for us. This is
      not limited to only shared libraries, but also referenced executables,
      scripts, Python libraries etc..
    </p><p>
      This makes packages self-contained, ensuring (apart data and
      configuration) that copying the runtime closure on another machine is
      sufficient to run the program. That's why Nix has
      <a class="link" href="https://nixos.org/nix/manual/#ch-relnotes-0.8" target="_top">one-click install</a>,
      or
      <a class="link" href="http://nixos.org/nixops/manual/#chap-introduction" target="_top">reliable deployment in the cloud</a>.
      All with one tool.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320166288"></a>9.6. Next pill</h2></div></div></div><p>
      ...we will introduce nix-shell. With nix-build we always build
      derivations from scratch: the source gets unpacked, configured, built
      and installed. But this may take a long time, think of WebKit. What if we
      want to apply some small changes and compile incrementally instead, yet
      keeping a self-contained environment similar to nix-build?
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="generic-builders.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="developing-with-nix-shell.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 8. Generic Builders </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 10. Developing with <span class="command"><strong>nix-shell</strong></span></td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 10. Developing with nix-shell</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="automatic-runtime-dependencies.html" title="Chapter 9. Automatic Runtime Dependencies" /><link rel="next" href="garbage-collector.html" title="Chapter 11. Garbage Collector" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 10. Developing with <span class="command"><strong>nix-shell</strong></span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="automatic-runtime-dependencies.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="garbage-collector.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="developing-with-nix-shell"></a>Chapter 10. Developing with <span class="command"><strong>nix-shell</strong></span></h1></div></div></div><p>
    Welcome to the 10th Nix pill. In the previous
    <a class="link" href="automatic-runtime-dependencies.html" title="Chapter 9. Automatic Runtime Dependencies">9th pill</a> we saw
    one of the powerful features of nix, automatic discovery of runtime
    dependencies and finalized the GNU hello world package.
  </p><p>
    Having returned from vacation, we want to hack a little the GNU hello
    world program. The nix-build tool allows for an isolated environment
    while building the derivation. Additionally, we'd like the same
    isolation in order to modify some source files of the project.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320156144"></a>10.1. What's nix-shell</h2></div></div></div><p>
      The <a class="link" href="https://nixos.org/nix/manual/#sec-nix-shell" target="_top">nix-shell</a>
      tool drops us in a shell by setting up the necessary environment
      variables to hack on a derivation. It does not build the derivation, it
      only serves as a preparation so that we can run the build steps manually.
    </p><p>
      I remind you, in a nix environment you don't have access to libraries and
      programs unless you install them with nix-env. However installing
      libraries with nix-env is not good practice. We prefer to have isolated
      environments for development.
    </p><pre class="screen">$ nix-shell hello.nix
[nix-shell]$ make
bash: make: command not found
[nix-shell]$ echo $baseInputs
/nix/store/jff4a6zqi0yrladx3kwy4v6844s3swpc-gnutar-1.27.1 [...]
</pre><p>
      First thing to notice, we call <span class="command"><strong>nix-shell</strong></span> on a nix
      expression which returns a derivation. We then enter a new bash shell,
      but it's really useless. We expected to have the GNU hello world build
      inputs available in PATH, including GNU make, but it's not the case.
    </p><p>
      But, we have the environment variables that we set in the derivation,
      like <code class="code">$baseInputs</code>, <code class="code">$buildInputs</code>,
      <code class="code">$src</code> and so on.
    </p><p>
      That means we can source our <code class="filename">builder.sh</code>, and it will
      build the derivation. You may get an error in the installation phase,
      because the user may not have the permission to write to
      <code class="filename">/nix/store</code>:
    </p><pre class="screen">[nix-shell]$ source builder.sh
...
</pre><p>
      It didn't install, but it built. Things to notice:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          We sourced builder.sh, therefore it ran all the steps including
          setting up the PATH for us.
        </p></li><li class="listitem"><p>
          The working directory is no more a temp directory created by nix-build, but the current directory. Therefore, hello-2.10 has been unpacked there.
        </p></li></ul></div><p>
      We're able to <span class="command"><strong>cd</strong></span> into hello-2.10 and type
      <span class="command"><strong>make</strong></span>, because now it's available.
    </p><p>
      In other words, <span class="command"><strong>nix-shell</strong></span> drops us in a shell with the
      same (or almost) environment used to run the builder!
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320142944"></a>10.2. A builder for nix-shell</h2></div></div></div><p>
      The previous steps are a bit annoying of course, but we can improve our
      builder to be more nix-shell friendly.
    </p><p>
      First of all, we were able to source <code class="filename">builder.sh</code>
      because it was in our current directory, but that's not nice. We want the
      <code class="filename">builder.sh</code> that is stored in the nix store, the one
      that would be used by <span class="command"><strong>nix-build</strong></span>. To do so, the right
      way is to pass the usual environment variable through the derivation.
    </p><p>
      <span class="underlined">Note</span>: <code class="code">$builder</code> is
      already defined, but it's the bash executable, not our
      <code class="filename">builder.sh</code>. Our <code class="filename">builder.sh</code> is
      an argument to bash.
    </p><p>
      Second, we don't want to run the whole builder, we only want it to setup
      the necessary environment for manually building the project. So we'll
      write two files, one for setting up the environment, and the real
      <code class="filename">builder.sh</code> that runs with
      <span class="command"><strong>nix-build</strong></span>.
    </p><p>
      Additionally, we'll wrap the phases in functions, it may be useful, and
      move the <code class="code">set -e</code> to the builder instead of the setup. The
      <code class="code">set -e</code> is annoying in <span class="command"><strong>nix-shell</strong></span>.
    </p><p>
      Here is our modified <code class="filename">autotools.nix</code>.
      Noteworthy is the <code class="code">setup = ./setup.sh;</code> attribute in the
      derivation, which adds <code class="filename">setup.sh</code> to the nix store and
      as usual, adds a <code class="code">$setup</code> environment variable in the builder.
    </p><pre class="programlisting">pkgs: attrs:
  with pkgs;
  let defaultAttrs = {
    builder = "${bash}/bin/bash";
    args = [ ./builder.sh ];
    setup = ./setup.sh;
    baseInputs = [ gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep patchelf findutils ];
    buildInputs = [];
    system = builtins.currentSystem;
  };
  in
derivation (defaultAttrs // attrs)
</pre><p>
      Thanks to that, we can split <code class="filename">builder.sh</code> into
      <code class="filename">setup.sh</code> and <code class="filename">builder.sh</code>. What
      <code class="filename">builder.sh</code> does is sourcing <code class="code">$setup</code> and
      calling the <code class="code">genericBuild</code> function. Everything else is just
      some bash changes.
    </p><p>
      Here is the modified <code class="filename">builder.sh</code>.
    </p><pre class="programlisting">set -e
source $setup
genericBuild
</pre><p>
      Here is the newly added <code class="filename">setup.sh</code>.
    </p><pre class="programlisting">unset PATH
for p in $baseInputs $buildInputs; do
  export PATH=$p/bin${PATH:+:}$PATH
done

function unpackPhase() {
  tar -xzf $src

  for d in *; do
    if [ -d "$d" ]; then
      cd "$d"
      break
    fi
  done
}

function configurePhase() {
  ./configure --prefix=$out
}

function buildPhase() {
  make
}

function installPhase() {
  make install
}

function fixupPhase() {
  find $out -type f -exec patchelf --shrink-rpath '{}' \; -exec strip '{}' \; 2&gt;/dev/null
}

function genericBuild() {
  unpackPhase
  configurePhase
  buildPhase
  installPhase
  fixupPhase
}
</pre><p>
      Finally, here is <code class="filename">hello.nix</code>.
    </p><pre class="programlisting">let
  pkgs = import &lt;nixpkgs&gt; {};
  mkDerivation = import ./autotools.nix pkgs;
in mkDerivation {
  name = "hello";
  src = ./hello-2.10.tar.gz;
}
</pre><p>
      Now back to nix-shell:
    </p><pre class="screen">$ nix-shell hello.nix
[nix-shell]$ source $setup
[nix-shell]$
</pre><p>
      Now you can run, for example, <code class="code">unpackPhase</code> which unpacks
      <code class="code">$src</code> and enters the directory. And you can run commands
      like <span class="command"><strong>./configure</strong></span>, <span class="command"><strong>make</strong></span> etc.
      manually, or run phases with their respective functions.
    </p><p>
      It's that straightforward, <span class="command"><strong>nix-shell</strong></span> builds the .drv file
      and its input dependencies, then drops into a shell by setting up the
      environment variables necessary to build the .drv, in particular those
      passed to the derivation function.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320118192"></a>10.3. Conclusion</h2></div></div></div><p>
      With <span class="command"><strong>nix-shell</strong></span> we're able to drop into an isolated
      environment for developing a project, with the necessary dependencies
      just like <span class="command"><strong>nix-build</strong></span> does. Additionally, we can build and
      debug the project manually, step by step like you would do in any other
      operating system. Note that we never installed <span class="command"><strong>gcc</strong></span>,
      <span class="command"><strong>make</strong></span>, etc. system-wide. These tools and libraries are
      available per-build.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320114880"></a>10.4. Next pill</h2></div></div></div><p>
      ...we will clean up the nix store. We wrote and built derivations, added
      stuff to nix store, but until now we never worried about cleaning up the
      used space in the store. It's time to collect some garbage.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="automatic-runtime-dependencies.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="garbage-collector.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 9. Automatic Runtime Dependencies </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 11. Garbage Collector</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 11. Garbage Collector</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="developing-with-nix-shell.html" title="Chapter 10. Developing with nix-shell" /><link rel="next" href="inputs-design-pattern.html" title="Chapter 12. Inputs Design Pattern" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 11. Garbage Collector</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="developing-with-nix-shell.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="inputs-design-pattern.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="garbage-collector"></a>Chapter 11. Garbage Collector</h1></div></div></div><p>
    Welcome to the 11th Nix pill. In the previous
    <a class="link" href="developing-with-nix-shell.html" title="Chapter 10. Developing with nix-shell">10th pill</a> we managed to
    obtain a self-contained development environment for a project. The concept
    is that <span class="command"><strong>nix-build</strong></span> is able to build a derivation
    in isolation, while <span class="command"><strong>nix-shell</strong></span> is able to drop us in a
    shell with (almost) the same environment used by <span class="command"><strong>nix-build</strong></span>.
    This allows us to debug, modify and manually build software.
  </p><p>
    Today we stop packaging and look at a mandatory nix component, the garbage
    collector. When using nix tools, often derivations are built. This include
    both .drv files and out paths. These artifacts go in the nix store, but
    we've never cared about deleting them until now.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320107904"></a>11.1. How does it work</h2></div></div></div><p>
      Other package managers, like <span class="command"><strong>dpkg</strong></span>, have ways of
      removing unused software. Nix is much more precise in its garbage
      collection compared to these other systems.
    </p><p>
      I bet with <span class="command"><strong>dpkg</strong></span>, <span class="command"><strong>rpm</strong></span> or similar
      traditional packaging systems, you end up having some unnecessary
      packages installed or dangling files. With nix this does not happen.
    </p><p>
      How do we determine whether a store path is still needed? The same way
      programming languages with a garbage collector decide whether an object
      is still alive.
    </p><p>
      Programming languages with a garbage collector have an important concept
      in order to keep track of live objects: GC roots. A GC root is an object
      that is always alive (unless explicitly removed as GC root). All objects
      recursively referred to by a GC root are live.
    </p><p>
      Therefore, the garbage collection process starts from GC roots, and
      recursively mark referenced objects as live. All other objects can be
      collected and deleted.
    </p><p>
      In Nix there's this same concept. Instead of being objects, of course,
      <a class="link" href="http://nixos.org/nix/manual/#ssec-gc-roots" target="_top">GC roots are store paths</a>.
      The implementation is very simple and transparent to the user. GC roots
      are stored under <code class="filename">/nix/var/nix/gcroots</code>. If there's a
      symlink to a store path, then that store path is a GC root.
    </p><p>
      Nix allows this directory to have subdirectories: it will simply recurse
      directories in search of symlinks to store paths.
    </p><p>
      So we have a list of GC roots. At this point, deleting dead store paths
      is as easy as you can imagine. We have the list of all live store paths,
      hence the rest of the store paths are dead.
    </p><p>
      In particular, Nix first moves dead store paths to
      <code class="filename">/nix/store/trash</code> which is an atomic operation.
      Afterwards, the trash is emptied.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320098880"></a>11.2. Playing with the GC</h2></div></div></div><p>
      Before playing with the GC, first run the
      <a class="link" href="http://nixos.org/nix/manual/#sec-nix-collect-garbage" target="_top">nix garbage collector</a>
      once, so that we have a clean playground for our experiments:
    </p><pre class="screen">$ nix-collect-garbage
finding garbage collector roots...
[...]
deleting unused links...
note: currently hard linking saves -0.00 MiB
1169 store paths deleted, 228.43 MiB freed
</pre><p>
      Perfect, if you run it again it won't find anything new to delete, as
      expected.
    </p><p>
      What's left in the nix store is everything being referenced from the GC
      roots.
    </p><p>
      Let's install for a moment bsd-games:
    </p><pre class="screen">$ nix-env -iA nixpkgs.bsdgames
$ readlink -f `which fortune`
/nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17/bin/fortune
$ nix-store -q --roots `which fortune`
/nix/var/nix/profiles/default-9-link
$ nix-env --list-generations
[...]
   9   2014-08-20 12:44:14   (current)
</pre><p>
      The nix-store command can be used to query the GC roots that refer to a
      given derivation. In this case, our current user environment does refer
      to bsd-games.
    </p><p>
      Now remove it, collect garbage and note that bsd-games is still in the nix
      store:
    </p><pre class="screen">$ nix-env -e bsd-games
uninstalling `bsd-games-2.17'
$ nix-collect-garbage
[...]
$ ls /nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17
bin  share
</pre><p>
      This is because the old generation is still in the nix store because it's a GC root. As we'll see below, all profiles and their generations are GC roots.
    </p><p>
      Removing a GC root is simple. Let's try deleting the generation that
      refers to bsd-games, collect garbage, and note that now bsd-games is no
      longer in the nix store:
    </p><pre class="screen">$ rm /nix/var/nix/profiles/default-9-link
$ nix-env --list-generations
[...]
   8   2014-07-28 10:23:24
  10   2014-08-20 12:47:16   (current)
$ nix-collect-garbage
[...]
$ ls /nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17
ls: cannot access /nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17: No such file or directory
</pre><p>
      <span class="underline">Note</span>:
      <span class="command"><strong>nix-env --list-generations</strong></span> does not rely on any
      particular metadata. It is able to list generations based solely on the
      file names under the profiles directory.
    </p><p>
      However we removed the link from
      <code class="filename">/nix/var/nix/profiles</code>, not from
      <code class="filename">/nix/var/nix/gcroots</code>. Turns out, that
      <code class="filename">/nix/var/nix/gcroots/profiles</code> is a symlink to
      <code class="filename">/nix/var/nix/profiles</code>. That is very handy. It means
      any profile and its generations are GC roots.
    </p><p>
      It's as simple as that, anything under
      <code class="filename">/nix/var/nix/gcroots</code> is a GC root. And anything not
      being garbage collected is because it's referred from one of the GC roots.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320085568"></a>11.3. Indirect roots</h2></div></div></div><p>
      Remember that building the GNU hello world package with
      <span class="command"><strong>nix-build</strong></span> produces a <code class="filename">result</code>
      symlink in the current directory. Despite the collected garbage done
      above, the <span class="command"><strong>hello</strong></span> program is still working: therefore
      it has not been garbage collected. Clearly, since there's no other
      derivation that depends upon the GNU hello world package, it must be a
      GC root.
    </p><p>
      In fact, <span class="command"><strong>nix-build</strong></span> automatically adds the result
      symlink as a GC root. Yes, not the built derivation, but the symlink.
      These GC roots are added under
      <code class="filename">/nix/var/nix/gcroots/auto</code>.
    </p><pre class="screen">$ ls -l /nix/var/nix/gcroots/auto/
total 8
drwxr-xr-x 2 nix nix 4096 Aug 20 10:24 ./
drwxr-xr-x 3 nix nix 4096 Jul 24 10:38 ../
lrwxrwxrwx 1 nix nix   16 Jul 31 10:51 xlgz5x2ppa0m72z5qfc78b8wlciwvgiz -&gt; /home/nix/result/
</pre><p>
      Don't care about the name of the symlink. What's important is that a
      symlink exists that point to <code class="filename">/home/nix/result</code>. This
      is called an <span class="bold"><strong>indirect GC root</strong></span>. That is,
      the GC root is effectively specified outside of
      <code class="filename">/nix/var/nix/gcroots</code>. Whatever
      <code class="filename">result</code> points to, it will not be garbage collected.
    </p><p>
      How do we remove the derivation then? There are two possibilities:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Remove the indirect GC root from
          <code class="filename">/nix/var/nix/gcroots/auto</code>.
        </p></li><li class="listitem"><p>
          Remove the <code class="filename">result</code> symlink.
        </p></li></ul></div><p>
      In the first case, the derivation will be deleted from the nix store, and
      <code class="filename">result</code> becomes a dangling symlink. In the second
      case, the derivation is removed as well as the indirect root in
      <code class="filename">/nix/var/nix/gcroots/auto</code>.
    </p><p>
      Running <span class="command"><strong>nix-collect-garbage</strong></span> after deleting the GC root
      or the indirect GC root, will remove the derivation from the store.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320071904"></a>11.4. Cleanup everything</h2></div></div></div><p>
      What's the main source of software duplication in the nix store? Clearly,
      GC roots due to <span class="command"><strong>nix-build</strong></span> and profile generations.
      Doing a <span class="command"><strong>nix-build</strong></span> results in a GC root for a build
      that somehow will refer to a specific version of <span class="package">glibc</span>,
      and other libraries. After an upgrade, if that build is not deleted by
      the user, it will not be garbage collected. Thus the old dependencies
      referred to by the build will not be deleted either.
    </p><p>
      Same goes for profiles. Manipulating the <span class="command"><strong>nix-env</strong></span>
      profile will create further generations. Old generations refer to old
      software, thus increasing duplication in the nix store after an upgrade.
    </p><p>
      What are the basic steps for upgrading and removing everything old,
      including old generations? In other words, do an upgrade similar to other
      systems, where they forget everything about the older state:
    </p><pre class="screen">$ nix-channel --update
$ nix-env -u --always
$ rm /nix/var/nix/gcroots/auto/*
$ nix-collect-garbage -d
</pre><p>
      First, we download a new version of the nixpkgs channel, which holds the
      description of all the software. Then we upgrade our installed packages
      with <span class="command"><strong>nix-env -u</strong></span>. That will bring us into a fresh new
      generation with all updated software.
    </p><p>
      Then we remove all the indirect roots generated by
      <span class="command"><strong>nix-build</strong></span>: beware, this will result in dangling
      symlinks. You may be smarter and also remove the target of those symlinks.
    </p><p>
      Finally, the <span class="command"><strong>-d</strong></span> option of
      <span class="command"><strong>nix-collect-garbage</strong></span> is used to delete old generations
      of all profiles, then collect garbage. After this, you lose the ability
      to rollback to any previous generation. So make sure the new generation
      is working well before running the command.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320063168"></a>11.5. Conclusion</h2></div></div></div><p>
      Garbage collection in Nix is a powerful mechanism to cleanup your system.
      The nix-store commands allow us to know why a certain derivation is in
      the nix store.
    </p><p>
      Cleaning up everything down to the oldest bit of software after an
      upgrade seems a bit contrived, but that's the price of having multiple
      generations, multiple profiles, multiple versions of software, thus
      rollbacks etc.. The price of having many possibilities.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320061104"></a>11.6. Next pill</h2></div></div></div><p>
      ...we will package another project and introduce what I call the "inputs"
      design pattern. We've only played with a single derivation until now,
      however we'd like to start organizing a small repository of software. The
      "inputs" pattern is widely used in nixpkgs; it allows us to decouple
      derivations from the repository itself and increase customization
      opportunities.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="developing-with-nix-shell.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="inputs-design-pattern.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 10. Developing with <span class="command"><strong>nix-shell</strong></span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 12. Inputs Design Pattern</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 12. Inputs Design Pattern</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="garbage-collector.html" title="Chapter 11. Garbage Collector" /><link rel="next" href="callpackage-design-pattern.html" title="Chapter 13. Callpackage Design Pattern" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 12. Inputs Design Pattern</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="garbage-collector.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="callpackage-design-pattern.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="inputs-design-pattern"></a>Chapter 12. Inputs Design Pattern</h1></div></div></div><p>
    Welcome to the 12th Nix pill. In the previous <a class="link" href="garbage-collector.html" title="Chapter 11. Garbage Collector">11th pill</a> we stopped packaging and cleaned up the system with the garbage collector.
  </p><p>
    We'll be resuming packaging, and improving different aspects of it. We've only packaged a hello world program so far, but what if we want to create a repository of multiple packages?
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320056000"></a>12.1. Repositories in Nix</h2></div></div></div><p>
      Nix is a tool for build and deployment, it does not enforce any particular repository format. A repository of packages is the main usage for Nix, but not the only possibility. It's more like a consequence due to the need of organizing packages.
    </p><p>
      Nix is a language, and it is powerful enough to let you choose the format of your own repository. In this sense, it is not declarative, but functional.
    </p><p>
      There is no preset directory structure or preset packaging policy. It's all about you and Nix.
    </p><p>
      The <code class="literal">nixpkgs</code> repository has a certain structure, which evolved and evolves with the time. Like other languages, Nix has its own history and therefore I'd like to say that it also has its own design patterns. Especially when packaging, you often do the same task again and again except for different software. It's inevitable to identify patterns during this process. Some of these patterns get reused if the community thinks it's a good way to package the software.
    </p><p>
      Some of the patterns I'm going to show do not apply only to Nix, but to other systems of course.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320051648"></a>12.2. The single repository pattern</h2></div></div></div><p>
      Before introducing the "<code class="literal">inputs</code>" pattern, we can start talking about another pattern first which I'd like to call "<code class="literal">single repository</code>" pattern.
    </p><p>
      Systems like Debian scatter packages in several small repositories. This can make it hard to track interdependent changes and to contribute to new packages.
    </p><p>
      Alternatively, systems like Gentoo put package descriptions all in a single repository.
    </p><p>
      The nix reference for packages is <a class="link" href="https://github.com/NixOS/nixpkgs" target="_top">nixpkgs</a>, a single repository of all descriptions of all packages. I find this approach very natural and attractive for new contributions.
    </p><p>
      For the rest of this chapter, we will adopt the single repository technique. The natural implementation in Nix is to create a top-level Nix expression, and one expression for each package. The top-level expression imports and combines all expressions in a giant attribute set with name -&gt; package pairs.
    </p><p>
      But isn't that heavy? It isn't, because Nix is a lazy language, it evaluates only what's needed! And that's why <code class="literal">nixpkgs</code> is able to maintain such a big software repository in a giant attribute set.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320045056"></a>12.3. Packaging graphviz</h2></div></div></div><p>
      We have packaged <span class="package">GNU hello world</span>, imagine you would like to package something else for creating at least a repository of two projects :-) . I chose <span class="package">graphviz</span>, which uses the standard autotools build system, requires no patching and dependencies are optional.
    </p><p>
      Download <span class="package">graphviz</span> from <a class="link" href="http://pkgs.fedoraproject.org/repo/pkgs/graphviz/graphviz-2.38.0.tar.gz/5b6a829b2ac94efcd5fa3c223ed6d3ae/graphviz-2.38.0.tar.gz" target="_top">here</a>. The <code class="filename">graphviz.nix</code> expression is straightforward:
    </p><pre class="screen">let
  pkgs = import &lt;nixpkgs&gt; {};
  mkDerivation = import ./autotools.nix pkgs;
in mkDerivation {
  name = "graphviz";
  src = ./graphviz-2.38.0.tar.gz;
}
</pre><p>
      Build with <span class="command"><strong>nix-build graphviz.nix</strong></span> and you will get runnable binaries under <code class="filename">result/bin</code>. Notice how we reused the same <code class="filename">autotools.nix</code> of <code class="filename">hello.nix.</code> Let's create a simple png:
    </p><pre class="screen">$ echo 'graph test { a -- b }'|result/bin/dot -Tpng -o test.png
Format: "png" not recognized. Use one of: canon cmap [...]
</pre><p>
      Oh of course... <span class="package">graphviz</span> doesn't know about png. It built only the output formats it supports natively, without using any extra library.
    </p><p>
      Remember, in <code class="filename">autotools.nix</code> there's a <code class="literal">buildInputs</code> variable which gets concatenated to <code class="literal">baseInputs</code>.  That would be the perfect place to add a build dependency. We created that variable exactly for this reason to be overridable from package expressions.
    </p><p>
      This 2.38 version of <span class="package">graphviz</span> has several plugins to output png. For simplicity, we will use <span class="package">libgd</span>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320032784"></a>12.4. Digression about gcc and ld wrappers</h2></div></div></div><p>
      The <span class="package">gd</span>, <span class="package">jpeg</span>, <span class="package">fontconfig</span> and <span class="package">bzip2</span> libraries (dependencies of <span class="package">gd</span>) don't use <span class="command"><strong>pkg-config</strong></span> to specify which flags to pass to the compiler. Since there's no global location for libraries, we need to tell <span class="command"><strong>gcc</strong></span> and <span class="command"><strong>ld</strong></span> where to find includes and libs.
    </p><p>
      The <code class="literal">nixpkgs</code> provides <span class="package">gcc</span> and <span class="package">binutils</span>, which we are currently using for our packaging. It also <a class="link" href="http://nixos.org/nixpkgs/manual/#ssec-setup-hooks" target="_top">provides wrappers</a> for them which allow passing extra arguments to <span class="command"><strong>gcc</strong></span> and <span class="command"><strong>ld</strong></span>, bypassing the project build systems:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">NIX_CFLAGS_COMPILE</code>: extra flags to <span class="command"><strong>gcc</strong></span> at compile time</p></li><li class="listitem"><p><code class="varname">NIX_LDFLAGS</code>: extra flags to <span class="command"><strong>ld</strong></span></p></li></ul></div><p>
    </p><p>
      What can we do about it? We can employ the same trick we did for <code class="varname">PATH</code>: automatically filling the variables from <code class="literal">buildInputs</code>. This is the relevant snippet of <code class="filename">setup.sh</code>:
    </p><pre class="screen">for p in $baseInputs $buildInputs; do
  if [ -d $p/bin ]; then
    export PATH="$p/bin${PATH:+:}$PATH"
  fi
  if [ -d $p/include ]; then
    export NIX_CFLAGS_COMPILE="-I $p/include${NIX_CFLAGS_COMPILE:+ }$NIX_CFLAGS_COMPILE"
  fi
  if [ -d $p/lib ]; then
    export NIX_LDFLAGS="-rpath $p/lib -L $p/lib${NIX_LDFLAGS:+ }$NIX_LDFLAGS"
  fi
done
</pre><p>
      Now adding derivations to <code class="literal">buildInputs</code> will add their <code class="filename">lib</code>, <code class="filename">include</code> and <code class="filename">bin</code> paths automatically in <code class="filename">setup.sh</code>.
    </p><p>
      The [-rpath] flag in <span class="command"><strong>ld</strong></span> is needed because at runtime, the executable must use exactly that version of the library.
    </p><p>
      If unneeded paths are specified, the <code class="literal">fixup</code> phase will shrink the <code class="literal">rpath</code> for us!
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320013968"></a>12.5. Completing graphviz with gd</h2></div></div></div><p>
      Finish the expression for <span class="package">graphviz</span> with <span class="package">gd</span> support (note the use of the <code class="literal">with</code> expression in <code class="literal">buildInputs</code> to avoid repeating <code class="literal">pkgs</code>):
    </p><pre class="screen">let
  pkgs = import &lt;nixpkgs&gt; {};
  mkDerivation = import ./autotools.nix pkgs;
in mkDerivation {
  name = "graphviz";
  src = ./graphviz-2.38.0.tar.gz;
  buildInputs = with pkgs; [ gd fontconfig libjpeg bzip2 ];
}
</pre><p>
      Now you can create the png! Ignore any error from <span class="package">fontconfig</span>, especially if you are in a <code class="literal">chroot</code>.

    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737320008256"></a>12.6. The repository expression</h2></div></div></div><p>
      Now that we have two packages, what's a good way to put them together in a single repository? We'll do something like <code class="literal">nixpkgs</code> does. With <code class="literal">nixpkgs</code>, we <code class="literal">import</code> it and then we pick derivations by accessing the giant attribute set.
    </p><p>
      For us nixers, this is a good technique, because it abstracts from the file names. We don't refer to a package by <code class="filename">REPO/some/sub/dir/package.nix</code> but by <code class="literal">importedRepo.package</code> (or <code class="literal">pkgs.package</code> in our examples).
    </p><p>
      Create a default.nix in the current directory:
    </p><pre class="screen">{
  hello = import ./hello.nix;
  graphviz = import ./graphviz.nix;
}
</pre><p>
      Ready to use! Try it with <span class="command"><strong>nix repl</strong></span>:
    </p><pre class="screen">$ nix repl
nix-repl&gt; :l default.nix
Added 2 variables.
nix-repl&gt; hello
«derivation /nix/store/dkib02g54fpdqgpskswgp6m7bd7mgx89-hello.drv»
nix-repl&gt; graphviz
«derivation /nix/store/zqv520v9mk13is0w980c91z7q1vkhhil-graphviz.drv»
</pre><p>
      With <span class="command"><strong>nix-build</strong></span>:
    </p><pre class="screen">$ nix-build default.nix -A hello
[...]
$ result/bin/hello
Hello, world!
</pre><p>
      The [-A] argument is used to access an attribute of the set from the given .nix expression.
    </p><p>
      <span class="bold"><strong>Important:</strong></span> why did we choose the <code class="filename">default.nix</code>? Because when a directory (by default the current directory) has a <code class="filename">default.nix</code>, that <code class="filename">default.nix</code> will be used (see <code class="literal">import</code> <a class="link" href="http://nixos.org/nix/manual/#ssec-builtins" target="_top">here</a>). In fact you can run <span class="command"><strong>nix-build -A hello</strong></span> without specifying <code class="filename">default.nix</code>.
    </p><p>
      For pythoners, it is similar to <code class="filename">__init__.py</code>.
    </p><p>
      With <span class="command"><strong>nix-env</strong></span>, install the package into your user environment:
    </p><pre class="screen">$ nix-env -f . -iA graphviz
[...]
$ dot -V
</pre><p>
      The [-f] option is used to specify the expression to use, in this case the current directory, therefore <code class="filename">./default.nix</code>.
    </p><p>
      The [-i] stands for installation.
    </p><p>
      The [-A] is the same as above for <span class="command"><strong>nix-build</strong></span>.
    </p><p>
      We reproduced the very basic behavior of <code class="literal">nixpkgs</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319987488"></a>12.7. The inputs pattern</h2></div></div></div><p>
      After a long preparation, we finally arrived. I know you're having a big doubt in this moment. It's about the <code class="filename">hello.nix</code> and <code class="filename">graphviz.nix</code>. They are very, very dependent on <code class="literal">nixpkgs</code>:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>First big problem: they import <code class="literal">nixpkgs</code> directly. In <code class="filename">autotools.nix</code> instead we pass <code class="literal">nixpkgs</code> as an argument. That's a much better approach.</p></li><li class="listitem"><p>Second problem: what if we want a variant of <span class="package">graphviz</span> without <span class="package">libgd</span> support?</p></li><li class="listitem"><p>Third problem: what if we want to test <span class="package">graphviz</span> with a particular <span class="package">libgd</span> version?</p></li></ul></div><p>
    </p><p>
      The current answers to the above questions are: change the expression to match your needs (or change the callee to match your needs).
    </p><p>
      With the <code class="literal">inputs</code> pattern, we decided to provide another answer: let the user change the <code class="literal">inputs</code> of the expression (or change the caller to pass different inputs).
    </p><p>
      By inputs of an expression, we refer to the set of derivations needed to build that expression. In this case:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">mkDerivation</code> from <span class="package">autotools</span>. Recall that <code class="literal">mkDerivation</code> has an implicit dependency on the toolchain.</p></li><li class="listitem"><p><span class="package">libgd</span> and its dependencies.</p></li></ul></div><p>
    </p><p>
      The src is also an input but it's pointless to change the source from the caller. For version bumps, in <code class="literal">nixpkgs</code> we prefer to write another expression (e.g. because patches are needed or different inputs are needed).
    </p><p>
      <span class="underline">Goal:</span> make package expressions independent of the repository.
    </p><p>
      How do we achieve that? The answer is simple: use functions to declare inputs for a derivation. Doing it for <code class="filename">graphviz.nix</code>, will make the derivation independent of the repository and customizable:
    </p><pre class="screen">{ mkDerivation, gdSupport ? true, gd, fontconfig, libjpeg, bzip2 }:

mkDerivation {
  name = "graphviz";
  src = ./graphviz-2.38.0.tar.gz;
  buildInputs = if gdSupport then [ gd fontconfig libjpeg bzip2 ] else [];
}
</pre><p>
      I recall that "<code class="literal">{...}: ...</code>" is the syntax for defining functions accepting an attribute set as argument.
    </p><p>
      We made <span class="package">gd</span> and its dependencies optional. If <code class="literal">gdSupport</code> is true (by default), we will fill <code class="literal">buildInputs</code> and thus <span class="package">graphviz</span> will be built with <span class="package">gd</span> support, otherwise it won't.
    </p><p>
      Now back to default.nix:
    </p><pre class="screen">let
  pkgs = import &lt;nixpkgs&gt; {};
  mkDerivation = import ./autotools.nix pkgs;
in with pkgs; {
  hello = import ./hello.nix { inherit mkDerivation; };
  graphviz = import ./graphviz.nix { inherit mkDerivation gd fontconfig libjpeg bzip2; };
  graphvizCore = import ./graphviz.nix {
    inherit mkDerivation gd fontconfig libjpeg bzip2;
    gdSupport = false;
  };
}
</pre><p>
      So we factorized the import of <code class="literal">nixpkgs</code> and <code class="literal">mkDerivation</code>, and also added a variant of <span class="package">graphviz</span> with <span class="package">gd</span> support disabled. The result is that both <code class="filename">hello.nix</code> (exercise for the reader) and <code class="filename">graphviz.nix</code> are independent of the repository and customizable by passing specific inputs.
    </p><p>
      If you wanted to build <span class="package">graphviz</span> with a specific version of <span class="package">gd</span>, it would suffice to pass <code class="literal">gd = ...;</code>.
    </p><p>
      If you wanted to change the toolchain, you may pass a different <code class="literal">mkDerivation</code> function.
    </p><p>
      Clearing up the syntax:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>In the end we return an attribute set from <code class="filename">default.nix</code>. With "<code class="literal">let</code>" we define some local variables.</p></li><li class="listitem"><p>We bring <code class="literal">pkgs</code> into the scope when defining the packages set, which is very convenient instead of typing everytime "<code class="literal">pkgs</code>".</p></li><li class="listitem"><p>We import <code class="filename">hello.nix</code> and <code class="filename">graphviz.nix</code>, which will return a function, and call it with a set of inputs to get back the derivation.</p></li><li class="listitem"><p>The "<code class="literal">inherit x</code>" syntax is equivalent to "<code class="literal">x = x</code>". So "<code class="literal">inherit gd</code>" here, combined to the above "<code class="literal">with pkgs;</code>" is equivalent to "<code class="literal">gd = pkgs.gd</code>".</p></li></ul></div><p>
    </p><p>
      You can find the whole repository at the <a class="link" href="https://gist.github.com/lethalman/734b168a0258b8a38ca2" target="_top">pill 12</a> gist.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319949888"></a>12.8. Conclusion</h2></div></div></div><p>
      The "<code class="literal">inputs</code>" pattern allows our expressions to be easily customizable through a set of arguments. These arguments could be flags, derivations, or whatever else. Our package expressions are functions, don't think there's any magic in there.
    </p><p>
      It also makes the expressions independent of the repository. Given that all the needed information is passed through arguments, it is possible to use that expression in any other context.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319947408"></a>12.9. Next pill</h2></div></div></div><p>
      ...we will talk about the "<code class="literal">callPackage</code>" design pattern. It is tedious to specify the names of the inputs twice, once in the top-level <code class="filename">default.nix</code>, and once in the package expression. With <code class="literal">callPackage</code>, we will implicitly pass the necessary inputs from the top-level expression.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="garbage-collector.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="callpackage-design-pattern.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 11. Garbage Collector </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 13. Callpackage Design Pattern</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 13. Callpackage Design Pattern</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="inputs-design-pattern.html" title="Chapter 12. Inputs Design Pattern" /><link rel="next" href="override-design-pattern.html" title="Chapter 14. Override Design Pattern" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 13. Callpackage Design Pattern</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="inputs-design-pattern.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="override-design-pattern.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="callpackage-design-pattern"></a>Chapter 13. Callpackage Design Pattern</h1></div></div></div><p>
    Welcome to the 13th Nix pill. In the previous <a class="link" href="inputs-design-pattern.html" title="Chapter 12. Inputs Design Pattern">12th pill</a> we have introduced the first basic design pattern for organizing a repository of software. In addition we packaged <span class="package">graphviz</span> to have at least another package for our little repository.
  </p><p>
    The next design pattern worth noting is what I'd like to call the <code class="literal">callPackage</code> pattern. This technique is extensively used in <a class="link" href="https://github.com/NixOS/nixpkgs" target="_top">nixpkgs</a>, it's the current standard for importing packages in a repository.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319938880"></a>13.1. The callPackage convenience</h2></div></div></div><p>
      In the previous pill, we underlined the fact that the inputs pattern is great to decouple packages from the repository, in that we can pass manually the inputs to the derivation. The derivation declares its inputs, and the caller passes the arguments.
    </p><p>
      However as with usual programming languages, we declare parameter names, and then we have to pass arguments. We do the job twice. With package management, we often see common patterns. In the case of <code class="literal">nixpkgs</code> it's the following.
    </p><p>
      Some package derivation:
    </p><pre class="screen">{ input1, input2, ... }:
...
</pre><p>
      Repository derivation:
    </p><pre class="screen">rec {
  lib1 = import package1.nix { inherit input1 input2 ...; };
  program2 = import package1.nix { inherit inputX inputY lib1 ...; };
}
</pre><p>
      Where inputs may even be packages in the repository itself (note the rec keyword). The pattern here is clear, often inputs have the same name of the attributes in the repository itself. Our desire is to pass those inputs from the repository automatically, and in case be able to specify a particular argument (that is, override the automatically passed default argument).
    </p><p>
      To achieve this, we will define a <code class="literal">callPackage</code> function with the following synopsis:
    </p><pre class="screen">{
  lib1 = callPackage package1.nix { };
  program2 = callPackage package2.nix { someoverride = overriddenDerivation; };
}
</pre><p>
      What should it do?
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Import the given expression, which in turn returns a function.</p></li><li class="listitem"><p>Determine the name of its arguments.</p></li><li class="listitem"><p>Pass default arguments from the repository set, and let us override those arguments.</p></li></ul></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319929776"></a>13.2. Implementing callPackage</h2></div></div></div><p>
      First of all, we need a way to introspect (reflection or whatever) at runtime the argument names of a function. That's because we want to automatically pass such arguments.
    </p><p>
      Then <code class="literal">callPackage</code> requires access to the whole packages set, because it needs to find the packages to pass automatically.
    </p><p>
      We start off simple with <span class="command"><strong></strong></span>:
    </p><pre class="screen">nix-repl&gt; add = { a ? 3, b }: a+b
nix-repl&gt; builtins.functionArgs add
{ a = true; b = false; }
</pre><p>
      Nix provides a builtin function to introspect the names of the arguments of a function. In addition, for each argument, it tells whether the argument has a default value or not. We don't really care about default values in our case. We are only interested in the argument names.
    </p><p>
      Now we need a set with all the <code class="literal">values</code>, let's call it <code class="literal">values</code>.  And a way to intersect the attributes of values with the function arguments:
    </p><pre class="screen">nix-repl&gt; values = { a = 3; b = 5; c = 10; }
nix-repl&gt; builtins.intersectAttrs values (builtins.functionArgs add)
{ a = true; b = false; }
nix-repl&gt; builtins.intersectAttrs (builtins.functionArgs add) values
{ a = 3; b = 5; }
</pre><p>
      Perfect, note from the example above that the <code class="literal">intersectAttrs</code> returns a set whose names are the intersection, and the attribute values are taken from the second set.
    </p><p>
      We're done, we have a way to get argument names from a function, and match with an existing set of attributes. This is our simple implementation of <code class="literal">callPackage</code>:
    </p><pre class="screen">nix-repl&gt; callPackage = set: f: f (builtins.intersectAttrs (builtins.functionArgs f) set)
nix-repl&gt; callPackage values add
8
nix-repl&gt; with values; add { inherit a b; }
8
</pre><p>
      Clearing up the syntax:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>We define a <code class="literal">callPackage</code> variable which is a function.</p></li><li class="listitem"><p>The second parameter is the function to "autocall".</p></li><li class="listitem"><p>We take the argument names of the function and intersect with the set of all values.</p></li><li class="listitem"><p>Finally we call the passed function <code class="literal">f</code> with the resulting intersection.</p></li></ul></div><p>
    </p><p>
      In the code above, I've also shown that the <code class="literal">callPackage</code> call is equivalent to directly calling <code class="literal">add a b</code>.
    </p><p>
      We achieved what we wanted. Automatically call functions given a set of possible arguments. If an argument is not found in the set, that's nothing special. It's a function call with a missing parameter, and that's an error (unless the function has varargs <code class="literal">...</code> as explained in the <a class="link" href="functions-and-imports.html" title="Chapter 5. Functions and Imports">5th pill</a>).
    </p><p>
      Or not. We missed something. Being able to override some of the parameters. We may not want to always call functions with values taken from the big set. Then we add a further parameter, which takes a set of overrides:
    </p><pre class="screen">nix-repl&gt; callPackage = set: f: overrides: f ((builtins.intersectAttrs (builtins.functionArgs f) set) // overrides)
nix-repl&gt; callPackage values add { }
8
nix-repl&gt; callPackage values add { b = 12; }
15
</pre><p>
      Apart from the increasing number of parenthesis, it should be clear that we simply do a set union between the default arguments, and the overriding set.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319911600"></a>13.3. Use callPackage to simplify the repository</h2></div></div></div><p>
      Given our brand new tool, we can simplify the repository expression (default.nix).
    </p><p>
      Let me write it down first:
    </p><pre class="screen">let
  nixpkgs = import &lt;nixpkgs&gt; {};
  allPkgs = nixpkgs // pkgs;
  callPackage = path: overrides:
    let f = import path;
    in f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides);
  pkgs = with nixpkgs; {
    mkDerivation = import ./autotools.nix nixpkgs;
    hello = callPackage ./hello.nix { };
    graphviz = callPackage ./graphviz.nix { };
    graphvizCore = callPackage ./graphviz.nix { gdSupport = false; };
  };
in pkgs
</pre><p>
      Wow, there's a lot to say here:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>We renamed the old <code class="literal">pkgs</code> of the previous pill to <code class="literal">nixpkgs</code>. Our package set is now instead named <code class="literal">pkgs</code>. Sorry for the confusion.</p></li><li class="listitem"><p>We needed a way to pass pkgs to <code class="literal">callPackage</code> somehow. Instead of returning the set of packages directly from <code class="filename">default.nix</code>, we first assign it to a <code class="literal">let</code> variable and reuse it in <code class="literal">callPackage</code>.</p></li><li class="listitem"><p>For convenience, in <code class="literal">callPackage</code> we first import the file, instead of calling it directly. Otherwise for each package we would have to write the <code class="literal">import</code>.</p></li><li class="listitem"><p>Since our expressions use packages from <code class="literal">nixpkgs</code>, in <code class="literal">callPackage</code> we use <code class="literal">allPkgs</code>, which is the union of <code class="literal">nixpkgs</code> and our packages.</p></li><li class="listitem"><p>We moved <code class="literal">mkDerivation</code> into <code class="literal">pkgs</code> itself, so that it also gets passed automatically.</p></li></ul></div><p>
    </p><p>
      Note how easy is to override arguments in the case of <span class="package">graphviz</span> without <span class="package">gd</span>. But most importantly, how easy it was to merge two repositories: <code class="literal">nixpkgs</code> and our <code class="literal">pkgs</code>!
    </p><p>
      The reader should notice a magic thing happening. We're defining <code class="literal">pkgs</code> in terms of <code class="literal">callPackage</code>, and <code class="literal">callPackage</code> in terms of <code class="literal">pkgs</code>. That magic is possible thanks to lazy evaluation.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319893360"></a>13.4. Conclusion</h2></div></div></div><p>
      The "<code class="literal">callPackage</code>" pattern has simplified our repository a lot. We're able to import packages that require some named arguments and call them automatically, given the set of all packages.
    </p><p>
      We've also introduced some useful builtin functions that allows us to introspect Nix functions and manipulate attributes. These builtin functions are not usually used when packaging software, rather to provide tools for packaging. That's why they are not documented in the <a class="link" href="http://nixos.org/nix/manual/" target="_top">nix manual</a>.
    </p><p>
      Writing a repository in nix is an evolution of writing convenient functions for combining the packages. This demonstrates even more how nix is a generic tool to build and deploy something, and how suitable it is to create software repositories with your own conventions.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319889424"></a>13.5. Next pill</h2></div></div></div><p>
      ...we will talk about the "<code class="literal">override</code>" design pattern. The <code class="literal">graphvizCore</code> seems straightforward. It starts from <code class="filename">graphviz.nix</code> and builds it without <span class="package">gd</span>. Now I want to give you another point of view: what if we instead wanted to start from <code class="literal">pkgs.graphviz</code> and disable <span class="package">gd</span>?
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="inputs-design-pattern.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="override-design-pattern.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 12. Inputs Design Pattern </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 14. Override Design Pattern</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 14. Override Design Pattern</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="callpackage-design-pattern.html" title="Chapter 13. Callpackage Design Pattern" /><link rel="next" href="nix-search-paths.html" title="Chapter 15. Nix Search Paths" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 14. Override Design Pattern</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="callpackage-design-pattern.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="nix-search-paths.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="override-design-pattern"></a>Chapter 14. Override Design Pattern</h1></div></div></div><p>
    Welcome to the 14th Nix pill. In the previous <a class="link" href="callpackage-design-pattern.html" title="Chapter 13. Callpackage Design Pattern">13th</a> pill we have introduced the <code class="literal">callPackage</code> pattern, used to simplify the composition of software in a repository.
  </p><p>
    The next design pattern is less necessary but useful in many cases and it's a good exercise to learn more about Nix.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319881136"></a>14.1. About composability</h2></div></div></div><p>
      Functional languages are known for being able to compose functions. In particular, you gain a lot from functions that are able to manipulate the original value into a new value having the same structure. So that in the end we're able to call multiple functions to have the desired modifications.
    </p><p>
      In Nix we mostly talk about <span class="bold"><strong>functions</strong></span> that accept inputs in order to return <span class="bold"><strong>derivations</strong></span>. In our world we want nice utility functions that are able to manipulate those structures. These utilities add some useful properties to the original value, and we must be able to apply more utilities on top of it.
    </p><p>
      For example let's say we have an initial derivation drv and we want it to be a drv with debugging information and also to apply some custom patches:
    </p><pre class="screen">debugVersion (applyPatches [ ./patch1.patch ./patch2.patch ] drv)</pre><p>
      The final result will be still the original derivation plus some changes. That's both interesting and very different from other packaging approaches, which is a consequence of using a functional language to describe packages.
    </p><p>
      Designing such utilities is not trivial in a functional language that is not statically typed, because understanding what can or cannot be composed is difficult. But we try to do the best.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319875264"></a>14.2. The override pattern</h2></div></div></div><p>
      In the <a class="link" href="inputs-design-pattern.html" title="Chapter 12. Inputs Design Pattern">pill 12</a> we introduced the inputs design pattern. We do not return a derivation picking dependencies directly from the repository, rather we declare the inputs and let the callers pass the necessary arguments.
    </p><p>
      In our repository we have a set of attributes that import the expressions of the packages and pass these arguments, getting back a derivation. Let's take for example the <span class="package">graphviz</span> attribute:
    </p><pre class="screen">graphviz = import ./graphviz.nix { inherit mkDerivation gd fontconfig libjpeg bzip2; };</pre><p>
      If we wanted to produce a derivation of <span class="package">graphviz</span> with a customized <span class="package">gd</span> version, we would have to repeat most of the above plus specifying an alternative <span class="package">gd</span>:
    </p><pre class="screen">mygraphviz = import ./graphviz.nix {
  inherit mkDerivation fontconfig libjpeg bzip2;
  gd = customgd;
};
</pre><p>
      That's hard to maintain. Using callPackage it would be easier:
    </p><pre class="screen">mygraphviz = callPackage ./graphviz.nix { gd = customgd; };</pre><p>
      But we may still be diverging from the original <span class="package">graphviz</span> in the repository.
    </p><p>
      We would like to avoid specifying the nix expression again, instead reuse the original <span class="package">graphviz</span> attribute in the repository and add our overrides like this:
    </p><pre class="screen">mygraphviz = graphviz.override { gd = customgd; };</pre><p>
      The difference is obvious, as well as the advantages of this approach.
    </p><p>
      <span class="underline">Note:</span> that <code class="literal">.override</code> is not a "method" in the OO sense as you may think. Nix is a functional language. That <code class="literal">.override</code> is simply an attribute of a set.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319863456"></a>14.3. The override implementation</h2></div></div></div><p>
      I remind you, the <span class="package">graphviz</span> attribute in the repository is the derivation returned by the function imported from <code class="filename">graphviz.nix</code>. We would like to add a further attribute named "<code class="literal">override</code>" to the returned set.
    </p><p>
      Let's start simple by first creating a function "<code class="literal">makeOverridable</code>" that takes a function and a set of original arguments to be passed to the function.
    </p><p>
      <span class="underline">Contract:</span> the wrapped function must return a set.
    </p><p>
      Let's write a lib.nix:
    </p><pre class="screen">{
  makeOverridable = f: origArgs:
    let
      origRes = f origArgs;
    in
      origRes // { override = newArgs: f (origArgs // newArgs); };
}
</pre><p>
      So <code class="literal">makeOverridable</code> takes a function and a set of original arguments. It returns the original returned set, plus a new <code class="literal">override</code> attribute.
    </p><p>
      This <code class="literal">override</code> attribute is a function taking a set of new arguments, and returns the result of the original function called with the original arguments unified with the new arguments. What a mess.
    </p><p>
      Let's try it with <code class="literal">nix repl</code>:
    </p><pre class="screen">$ nix repl
nix-repl&gt; :l lib.nix
Added 1 variables.
nix-repl&gt; f = { a, b }: { result = a+b; }
nix-repl&gt; f { a = 3; b = 5; }
{ result = 8; }
nix-repl&gt; res = makeOverridable f { a = 3; b = 5; }
nix-repl&gt; res
{ override = «lambda»; result = 8; }
nix-repl&gt; res.override { a = 10; }
{ result = 15; }
</pre><p>
      Note that the function <code class="literal">f</code> does not return the plain sum but a set, because of the contract. You didn't forget already, did you? :-)
    </p><p>
      The variable <code class="literal">res</code> is the result of the function call without any override. It's easy to see in the definition of <code class="literal">makeOverridable</code>. In addition you can see the new <code class="literal">override</code> attribute being a function.
    </p><p>
      Calling that <code class="literal">.override</code> with a set will invoke the original function with the overrides, as expected.
    </p><p>
      But: we can't override again! Because the returned set with result 15 does not have an <code class="literal">override</code> attribute!
    </p><p>
      That's bad, it breaks further compositions.
    </p><p>
      The solution is simple, the <code class="literal">.override</code> function should make the result overridable again:
    </p><pre class="screen">rec {
  makeOverridable = f: origArgs:
    let
      origRes = f origArgs;
    in
      origRes // { override = newArgs: makeOverridable f (origArgs // newArgs); };
}
</pre><p>
      Please note the <code class="literal">rec</code> keyword. It's necessary so that we can refer to <code class="literal">makeOverridable</code> from <code class="literal">makeOverridable</code> itself.
    </p><p>
      Now let's try overriding twice:
    </p><pre class="screen">nix-repl&gt; :l lib.nix
Added 1 variables.
nix-repl&gt; f = { a, b }: { result = a+b; }
nix-repl&gt; res = makeOverridable f { a = 3; b = 5; }
nix-repl&gt; res2 = res.override { a = 10; }
nix-repl&gt; res2
{ override = «lambda»; result = 15; }
nix-repl&gt; res2.override { b = 20; }
{ override = «lambda»; result = 30; }
</pre><p>
      Success! The result is 30, as expected because a is overridden to 10 in the first override, and b to 20.
    </p><p>
      Now it would be nice if <code class="literal">callPackage</code> made our derivations overridable. That was the goal of this pill after all. This is an exercise for the reader.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319842480"></a>14.4. Conclusion</h2></div></div></div><p>
      The "<code class="literal">override</code>" pattern simplifies the way we customize packages starting from an existing set of packages. This opens a world of possibilities about using a central repository like <code class="literal">nixpkgs</code>, and defining overrides on our local machine without even modifying the original package.
    </p><p>
      Dream of a custom isolated <span class="command"><strong>nix-shell</strong></span> environment for testing <span class="package">graphviz</span> with a custom <span class="package">gd</span>:
    </p><pre class="screen">debugVersion (graphviz.override { gd = customgd; })</pre><p>
      Once a new version of the overridden package comes out in the repository, the customized package will make use of it automatically.
    </p><p>
      The key in Nix is to find powerful yet simple abstractions in order to let the user customize his environment with highest consistency and lowest maintenance time, by using predefined composable components.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319836752"></a>14.5. Next pill</h2></div></div></div><p>
      ...we will talk about Nix search paths. By search path I mean a place in the file system where Nix looks for expressions. You may have wondered, where does that holy <code class="literal">&lt;nixpkgs&gt;</code> come from?
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="callpackage-design-pattern.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="nix-search-paths.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 13. Callpackage Design Pattern </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 15. Nix Search Paths</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 15. Nix Search Paths</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="override-design-pattern.html" title="Chapter 14. Override Design Pattern" /><link rel="next" href="nixpkgs-parameters.html" title="Chapter 16. Nixpkgs Parameters" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 15. Nix Search Paths</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="override-design-pattern.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="nixpkgs-parameters.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="nix-search-paths"></a>Chapter 15. Nix Search Paths</h1></div></div></div><p>
    Welcome to the 15th Nix pill. In the previous <a class="link" href="override-design-pattern.html" title="Chapter 14. Override Design Pattern">14th</a> pill we have introduced the "override" pattern, useful for writing variants of derivations by passing different inputs.
  </p><p>
    Assuming you followed the previous posts, I hope you are now ready to understand <code class="literal">nixpkgs</code>. But we have to find <code class="literal">nixpkgs</code> in our system first! So this is the step: introducing some options and environment variables used by nix tools.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319830080"></a>15.1. The NIX_PATH</h2></div></div></div><p>
      The <a class="link" href="http://nixos.org/nix/manual/#sec-common-env" target="_top">NIX_PATH environment variable</a> is very important. It's very similar to the <code class="varname">PATH</code> environment variable. The syntax is similar, several paths are separated by a colon <code class="literal">:</code>. Nix will then search for something in those paths from left to right.
    </p><p>
      Who uses <code class="varname">NIX_PATH</code>? The nix expressions! Yes, <code class="varname">NIX_PATH</code> is not of much use by the nix tools themselves, rather it's used when writing nix expressions.
    </p><p>
      In the shell for example, when you execute the command <span class="command"><strong>ping</strong></span>, it's being searched in the <code class="varname">PATH</code> directories. The first one found is the one being used.
    </p><p>
      In nix it's exactly the same, however the syntax is different. Instead of just typing <span class="command"><strong>ping</strong></span> you have to type <code class="literal">&lt;ping&gt;</code>. Yes, I know... you are already thinking of <code class="literal">&lt;nixpkgs&gt;</code>. However don't stop reading here, let's keep going.
    </p><p>
      What's <code class="varname">NIX_PATH</code> good for? Nix expressions may refer to an "abstract" path such as <code class="literal">&lt;nixpkgs&gt;</code>, and it's possible to override it from the command line.
    </p><p>
      For ease we will use <span class="command"><strong>nix-instantiate --eval</strong></span> to do our tests. I remind you, <a class="link" href="http://nixos.org/nix/manual/#sec-nix-instantiate" target="_top">nix-instantiate</a> is used to evaluate nix expressions and generate the .drv files. Here we are not interested in building derivations, so evaluation is enough. It can be used for one-shot expressions.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319819088"></a>15.2. Fake it a little</h2></div></div></div><p>
      It's useless from a nix view point, but I think it's useful for your own understanding. Let's use <code class="varname">PATH</code> itself as <code class="varname">NIX_PATH</code>, and try to locate <span class="command"><strong>ping</strong></span> (or another binary if you don't have it).
    </p><pre class="screen">$ nix-instantiate --eval -E '&lt;ping&gt;'
error: file `ping' was not found in the Nix search path (add it using $NIX_PATH or -I)
$ NIX_PATH=$PATH nix-instantiate --eval -E '&lt;ping&gt;'
/bin/ping
$ nix-instantiate -I /bin --eval -E '&lt;ping&gt;'
/bin/ping
</pre><p>
      Great. At first attempt nix obviously said  could not be found anywhere in the search path. Note that the [-I] option accepts a single directory. Paths added with  [-I] take precedence over <code class="varname">NIX_PATH</code>.
    </p><p>
      The <code class="varname">NIX_PATH</code> also accepts a different yet very handy syntax: "<code class="literal">somename=somepath</code>". That is, instead of searching inside a directory for a name, we specify exactly the value of that name.
    </p><pre class="screen">$ NIX_PATH="ping=/bin/ping" nix-instantiate --eval -E '&lt;ping&gt;'
/bin/ping
$ NIX_PATH="ping=/bin/foo" nix-instantiate --eval -E '&lt;ping&gt;'
error: file `ping' was not found in the Nix search path (add it using $N
</pre><p>
      Note in the second case how Nix checks whether the path exists or not.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319811120"></a>15.3. The path to repository</h2></div></div></div><p>
      You are out of curiosity, right?
    </p><pre class="screen">$ nix-instantiate --eval -E '&lt;nixpkgs&gt;'
/home/nix/.nix-defexpr/channels/nixpkgs
$ echo $NIX_PATH
nixpkgs=/home/nix/.nix-defexpr/channels/nixpkgs
</pre><p>
      You may have a different path, depending on how you added channels etc.. Anyway that's the whole point. The <code class="literal">&lt;nixpkgs&gt;</code> stranger that we used in our nix expressions, is referring to a path in the filesystem specified by <code class="varname">NIX_PATH</code>.
    </p><p>
      You can list that directory and realize it's simply a checkout of the nixpkgs repository at a specific commit (hint: <code class="literal">.version-suffix</code>).
    </p><p>
      The <code class="varname">NIX_PATH</code> variable is exported by <code class="filename">nix.sh</code>, and that's the reason why I always asked you to <a class="link" href="https://nixos.org/nix/manual/#ch-env-variables" target="_top">source nix.sh</a> at the beginning of my posts.
    </p><p>
      You may wonder: then I can also specify a different <a class="link" href="https://github.com/NixOS/nixpkgs" target="_top">nixpkgs</a> path to, e.g., a <span class="command"><strong>git checkout</strong></span> of <code class="literal">nixpkgs</code>? Yes, you can and I encourage doing that. We'll talk about this in the next pill.
    </p><p>
      Let's define a path for our repository, then! Let's say all the <code class="filename">default.nix</code>, <code class="filename">graphviz.nix</code> etc. are under <code class="filename">/home/nix/mypkgs</code>:
    </p><pre class="screen">$ export NIX_PATH=mypkgs=/home/nix/mypkgs:$NIX_PATH
$ nix-instantiate --eval '&lt;mypkgs&gt;'
{ graphviz = &lt;code&gt;; graphvizCore = &lt;code&gt;; hello = &lt;code&gt;; mkDerivation = &lt;code&gt;; }

</pre><p>
      Yes, <span class="command"><strong>nix-build</strong></span> also accepts paths with angular brackets. We first evaluate the whole repository (<code class="filename">default.nix</code>) and then peek the <span class="package">graphviz</span> attribute.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319798032"></a>15.4. A big word about nix-env</h2></div></div></div><p>
      The <a class="link" href="http://nixos.org/nix/manual/#sec-nix-env" target="_top">nix-env</a> command is a little different than <span class="command"><strong>nix-instantiate</strong></span> and <span class="command"><strong>nix-build</strong></span>. Whereas <span class="command"><strong>nix-instantiate</strong></span> and <span class="command"><strong>nix-build</strong></span> require a starting nix expression, <span class="command"><strong>nix-env</strong></span> does not.
    </p><p>
      You may be crippled by this concept at the beginning, you may think <span class="command"><strong>nix-env</strong></span> uses <code class="varname">NIX_PATH</code> to find the <code class="literal">nixpkgs</code> repository. But that's not it.
    </p><p>
      The <span class="command"><strong>nix-env</strong></span> command uses <code class="filename">~/.nix-defexpr</code>, which is also part of <code class="varname">NIX_PATH</code> by default, but that's only a coincidence. If you empty <code class="varname">NIX_PATH</code>, <span class="command"><strong>nix-env</strong></span> will still be able to find derivations because of <code class="filename">~/.nix-defexpr</code>.
    </p><p>
      So if you run <span class="command"><strong>nix-env -i graphviz</strong></span> inside your repository, it will install the nixpkgs one. Same if you set <code class="varname">NIX_PATH</code> to point to your repository.
    </p><p>
      In order to specify an alternative to <code class="filename">~/.nix-defexpr</code> it's possible to use the  [-f] option:
    </p><pre class="screen">$ nix-env -f '&lt;mypkgs&gt;' -i graphviz
warning: there are multiple derivations named `graphviz'; using the first one
replacing old `graphviz'
installing `graphviz'
</pre><p>
      Oh why did it say there's another derivation named <span class="package">graphviz</span>? Because both <code class="literal">graphviz</code> and <code class="literal">graphvizCore</code> attributes in our repository have the name "graphviz" for the derivation:
    </p><pre class="screen">$ nix-env -f '&lt;mypkgs&gt;' -qaP
graphviz      graphviz
graphvizCore  graphviz
hello         hello
</pre><p>
      By default <span class="command"><strong>nix-env</strong></span> parses all derivations and use the derivation names to interpret the command line. So in this case "graphviz" matched two derivations. Alternatively, like for <span class="command"><strong>nix-build</strong></span>, one can use  [-A] to specify an attribute name instead of a derivation name:
    </p><pre class="screen">$ nix-env -f '&lt;mypkgs&gt;' -i -A graphviz
replacing old `graphviz'
installing `graphviz'
</pre><p>
      This form, other than being more precise, it's also faster because <span class="command"><strong>nix-env</strong></span> does not have to parse all the derivations.
    </p><p>
      For completeness: you must install <code class="literal">graphvizCore</code> with  [-A,] since without the  [-A] switch it's ambiguous.
    </p><p>
      In summary, it may happen when playing with nix that <span class="command"><strong>nix-env</strong></span> peeks a different derivation than <span class="command"><strong>nix-build</strong></span>. In such case you probably specified <code class="varname">NIX_PATH</code>, but <span class="command"><strong>nix-env</strong></span> is instead looking into <code class="filename">~/.nix-defexpr</code>.
    </p><p>
      Why is <span class="command"><strong>nix-env</strong></span> having this different behavior? I don't know specifically by myself either, but the answers could be:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> tries to be generic, thus it does not look for <code class="literal">nixpkgs</code> in <code class="varname">NIX_PATH</code>, rather it looks in <code class="filename">~/.nix-defexpr</code>.</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> is able to merge multiple trees in <code class="filename">~/.nix-defexpr</code> by looking at all the possible derivations</p></li></ul></div><p>
    </p><p>
      It may also happen to you <span class="bold"><strong>that you cannot match a derivation name when installing</strong></span>, because of the derivation name vs  [-A] switch described above. Maybe <span class="command"><strong>nix-env</strong></span> wanted to be more friendly in this case for default user setups.
    </p><p>
      It may or may not make sense for you, or it's like that for historical reasons, but that's how it works currently, unless somebody comes up with a better idea.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319767312"></a>15.5. Conclusion</h2></div></div></div><p>
      The <code class="varname">NIX_PATH</code> variable is the search path used by nix when using the angular brackets syntax. It's possible to refer to "abstract" paths inside nix expressions and define the "concrete" path by means of <code class="varname">NIX_PATH</code>, or the usual  [-I] flag in nix tools.
    </p><p>
      We've also explained some of the uncommon <span class="command"><strong>nix-env</strong></span> behaviors for newcomers. The <span class="command"><strong>nix-env</strong></span> tool does not use <code class="varname">NIX_PATH</code> to search for packages, but rather for <code class="filename">~/.nix-defexpr</code>. Beware of that!
    </p><p>
      In general do not abuse <code class="varname">NIX_PATH</code>, when possible use relative paths when writing your own nix expressions. Of course, in the case of <code class="literal">&lt;nixpkgs&gt;</code> in our repository, that's a perfectly fine usage of <code class="varname">NIX_PATH</code>. Instead, inside our repository itself, refer to expressions with relative paths like <code class="filename">./hello.nix</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319759904"></a>15.6. Next pill</h2></div></div></div><p>
      ...we will finally dive into <code class="literal">nixpkgs</code>. Most of the techniques we have developed in this series are already in <code class="literal">nixpkgs</code>, like <code class="literal">mkDerivation</code>, <code class="literal">callPackage</code>, <code class="literal">override</code>, etc., but of course better. With time, those base utilities get enhanced by the community with more features in order to handle more and more use cases and in a more general way.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="override-design-pattern.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="nixpkgs-parameters.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 14. Override Design Pattern </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 16. Nixpkgs Parameters</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 16. Nixpkgs Parameters</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="nix-search-paths.html" title="Chapter 15. Nix Search Paths" /><link rel="next" href="nixpkgs-overriding-packages.html" title="Chapter 17. Nixpkgs Overriding Packages" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 16. Nixpkgs Parameters</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="nix-search-paths.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="nixpkgs-overriding-packages.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="nixpkgs-parameters"></a>Chapter 16. Nixpkgs Parameters</h1></div></div></div><p>
    Welcome to the 16th Nix pill. In the previous <a class="link" href="nix-search-paths.html" title="Chapter 15. Nix Search Paths">15th</a> pill we've realized how nix finds expressions with the angular brackets syntax, so that we finally know where is <code class="literal">&lt;nixpkgs&gt;</code> located on our system.
  </p><p>
    We can start diving into the <a class="link" href="https://github.com/NixOS/nixpkgs" target="_top">nixpkgs repository</a>, through all the various tools and design patterns. Please note that also <code class="literal">nixpkgs</code> has its own manual, underlying the difference between the general <code class="literal">nix</code> language and the <code class="literal">nixpkgs</code> repository.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319749840"></a>16.1. The default.nix expression</h2></div></div></div><p>
      We will not start inspecting packages at the beginning, rather the general structure of <code class="literal">nixpkgs</code>.
    </p><p>
      In our custom repository we created a <code class="filename">default.nix</code> which composed the expressions of the various packages.
    </p><p>
      Also <code class="literal">nixpkgs</code> has its own <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/default.nix" target="_top">default.nix</a>, which is the one being loaded when referring to <code class="literal">&lt;nixpkgs&gt;</code>. It does a simple thing: check whether the <code class="literal">nix</code> version is at least 1.7 (at the time of writing this blog post). Then import <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/all-packages.nix" target="_top">pkgs/top-level/all-packages.nix</a>. From now on, we will refer to this set of packages as <span class="bold"><strong>pkgs</strong></span>.
    </p><p>
      The <code class="filename">all-packages.nix</code> is then the file that composes all the packages. Note the <code class="filename">pkgs/</code> subdirectory, while nixos is in the <code class="filename">nixos/</code> subdirectory.
    </p><p>
      The <code class="filename">all-packages.nix</code> is a bit contrived. First of all, it's a function. It accepts a couple of interesting parameters:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">system</code>: defaults to the current system</p></li><li class="listitem"><p><code class="literal">config</code>: defaults to null</p></li><li class="listitem"><p>others...</p></li></ul></div><p>
    </p><p>
      The <span class="bold"><strong>system</strong></span> parameter, as per comment in the expression, it's the system for which the packages will be built. It allows for example to install i686 packages on amd64 machines.
    </p><p>
      The <span class="bold"><strong>config</strong></span> parameter is a simple attribute set. Packages can read some of its values and change the behavior of some derivations.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319735008"></a>16.2. The system parameter</h2></div></div></div><p>
      You will find this parameter in many other .nix expressions (e.g. release expressions). The reason is that, given pkgs accepts a system parameter, then whenever you want to import pkgs you also want to pass through the value of system. E.g.:
    </p><p>
      <code class="filename">myrelease.nix</code>:
    </p><pre class="screen">{ system ? builtins.currentSystem }:

let pkgs = import &lt;nixpkgs&gt; { inherit system; };
...
</pre><p>
      Why is it useful? With this parameter it's very easy to select a set of packages for a particular system. For example:
    </p><pre class="screen">nix-build -A psmisc --argstr system i686-linux</pre><p>
      This will build the <span class="package">psmisc</span> derivation for i686-linux instead of x86_64-linux. This concept is very similar to multi-arch of Debian.
    </p><p>
      The setup for cross compiling is also in <code class="literal">nixpkgs</code>, however it's a little contrived to talk about it and I don't know much of it either.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319729280"></a>16.3. The config parameter</h2></div></div></div><p>
      I'm sure on the wiki or other manuals you've read about <code class="filename">~/.nixpkgs/config.nix</code> and I'm sure you've wondered whether that's hardcoded in nix. It's not, it's in <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/all-packages.nix#L45" target="_top">nixpkgs</a>.
    </p><p>
      The <code class="filename">all-packages.nix</code> expression accepts the <code class="literal">config</code> parameter. If it's <code class="literal">null</code>, then it reads the <code class="varname">NIXPKGS_CONFIG</code> environment variable. If not specified, <code class="literal">nixpkgs</code> will peek <code class="filename">$HOME/.nixpkgs/config.nix</code>.
    </p><p>
      After determining <code class="filename">config.nix</code>, it will be imported as nix expression, and that will be the value of <code class="literal">config</code> (in case it hasn't been passed as parameter to import <code class="literal">&lt;nixpkgs&gt;</code>).
    </p><p>
      The <code class="literal">config</code> is available in the resulting repository:
    </p><pre class="screen">$ nix repl
nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}
nix-repl&gt; pkgs.config
{ }
nix-repl&gt; pkgs = import &lt;nixpkgs&gt; { config = { foo = "bar"; }; }
nix-repl&gt; pkgs.config
{ foo = "bar"; }
</pre><p>
      What attributes go in <code class="literal">config</code> is a matter of convenience and conventions.
    </p><p>
      For example, <code class="literal">config.allowUnfree</code> is an attribute that forbids building packages that have an unfree license by default. The <code class="literal">config.pulseaudio</code> setting tells whether to build packages with <span class="package">pulseaudio</span> support or not where applicable and when the derivation obeys to the setting.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319717328"></a>16.4. About .nix functions</h2></div></div></div><p>
      A <code class="literal">.nix</code> file contains a nix expression. Thus it can also be a function. I remind you that <span class="command"><strong>nix-build</strong></span> expects the expression to return a derivation. Therefore it's natural to return straight a derivation from a <code class="literal">.nix</code> file. However, it's also very natural for the <code class="literal">.nix</code> file to accept some parameters, in order to tweak the derivation being returned.
    </p><p>
      In this case, nix does a trick:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If the expression is a derivation, well build it.</p></li><li class="listitem"><p>If the expression is a function, call it and build the resulting derivation.</p></li></ul></div><p>
    </p><p>
      For example you can nix-build the <code class="literal">.nix</code> file below:
    </p><pre class="screen">{ pkgs ? import &lt;nixpkgs&gt; {} }:

pkgs.psmisc
</pre><p>
      Nix is able to call the function because the pkgs parameter has a default value. This allows you to pass a different value for pkgs using the <code class="literal">--arg</code> option.
    </p><p>
      Does it work if you have a function returning a function that returns a derivation? No, Nix only calls the function it encounters once.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319709104"></a>16.5. Conclusion</h2></div></div></div><p>
      We've unleashed the <code class="literal">&lt;nixpkgs&gt;</code> repository. It's a function that accepts some parameters, and returns the set of all packages. Due to laziness, only the accessed derivations will be built.
    </p><p>
      You can use this repository to build your own packages as we've seen in the previous pill when creating our own repository.
    </p><p>
      Lately I'm a little busy with the NixOS 14.11 release and other stuff, and I'm also looking toward migrating from blogger to a more coder-oriented blogging platform. So sorry for the delayed and shorter pills :)
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319706128"></a>16.6. Next pill</h2></div></div></div><p>
      ...we will talk about overriding packages in the <code class="literal">nixpkgs</code> repository. What if you want to change some options of a library and let all other packages pick the new library? One possibility is to use, like described above, the <code class="literal">config</code> parameter when applicable. The other possibility is to override derivations.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="nix-search-paths.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="nixpkgs-overriding-packages.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 15. Nix Search Paths </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 17. Nixpkgs Overriding Packages</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 17. Nixpkgs Overriding Packages</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="nixpkgs-parameters.html" title="Chapter 16. Nixpkgs Parameters" /><link rel="next" href="nix-store-paths.html" title="Chapter 18. Nix Store Paths" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 17. Nixpkgs Overriding Packages</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="nixpkgs-parameters.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="nix-store-paths.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="nixpkgs-overriding-packages"></a>Chapter 17. Nixpkgs Overriding Packages</h1></div></div></div><p>
    Welcome to the 17th Nix pill. In the previous <a class="link" href="nixpkgs-parameters.html" title="Chapter 16. Nixpkgs Parameters">16th</a> pill we have started to dive into the <a class="link" href="http://github.com/NixOS/nixpkgs" target="_top">nixpkgs repository</a>. <code class="literal">Nixpkgs</code> is a function, and we've looked at some parameters like <code class="literal">system</code> and <code class="literal">config</code>.
  </p><p>
    Today we'll talk about a special attribute: <code class="literal">config.packageOverrides</code>. Overriding packages in a set with fixed point can be considered another design pattern in nixpkgs.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319697232"></a>17.1. Overriding a package</h2></div></div></div><p>
      Recall the override design pattern from the <a class="link" href="override-design-pattern.html" title="Chapter 14. Override Design Pattern">nix pill 14</a>. Instead of calling a function with parameters directly, we make the call (function + parameters) overridable.
    </p><p>
      We put the override function in the returned attribute set of the original function call.
    </p><p>
      Take for example <span class="package">graphviz</span>. It has an input parameter <span class="package">xorg</span>. If it's null, then <span class="package">graphviz</span> will build without X support.
    </p><pre class="screen">$ nix repl
nix-repl&gt; :l &lt;nixpkgs&gt;
Added 4360 variables.
nix-repl&gt; :b graphviz.override { xorg = null; }
</pre><p>
      This will build <span class="package">graphviz</span> without X support, it's as simple as that.
    </p><p>
      However let's say a package <code class="literal">P</code> depends on <span class="package">graphviz</span>, how do we make <code class="literal">P</code> depend on the new <span class="package">graphviz</span> without X support?
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319689248"></a>17.2. In an imperative world...</h2></div></div></div><p>
      ...you could do something like this:
    </p><pre class="screen">pkgs = import &lt;nixpkgs&gt; {};
pkgs.graphviz = pkgs.graphviz.override { xorg = null; };
build(pkgs.P)
</pre><p>
      Given <code class="literal">pkgs.P</code> depends on <code class="literal">pkgs.graphviz</code>, it's easy to build <code class="literal">P</code> with the replaced <span class="package">graphviz</span>. On a pure functional language it's not that easy because you can assign to variables only once.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319685120"></a>17.3. Fixed point</h2></div></div></div><p>
      The fixed point with lazy evaluation is crippling but about necessary in a language like Nix. It lets us achieve something similar to what we'd do imperatively.
    </p><p>
      Follows the definition of fixed point in <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/lib/trivial.nix#L21" target="_top">nixpkgs</a>:
    </p><pre class="screen"># Take a function and evaluate it with its own returned value.
fix = f: let result = f result; in result;
</pre><p>
      It's a function that accepts a function <code class="literal">f</code>, calls <code class="literal">f result</code> on the result just returned by <code class="literal">f result</code> and returns it. In other words it's <code class="literal">f(f(f(....</code>
    </p><p>
      At first sight, it's an infinite loop. With lazy evaluation it isn't, because the call is done only when needed.
    </p><pre class="screen">nix-repl&gt; fix = f: let result = f result; in result
nix-repl&gt; pkgs = self: { a = 3; b = 4; c = self.a+self.b; }
nix-repl&gt; fix pkgs
{ a = 3; b = 4; c = 7; }
</pre><p>
      Without the <code class="literal">rec</code> keyword, we were able to refer to <code class="literal">a</code> and <code class="literal">b</code> of the same set.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>First <code class="literal">pkgs</code> gets called with an unevaluated thunk <code class="literal">(pkgs(pkgs(...)</code></p></li><li class="listitem"><p>To set the value of <code class="literal">c</code> then <code class="literal">self.a</code> and <code class="literal">self.b</code> are evaluated.</p></li><li class="listitem"><p>The <code class="literal">pkgs</code> function gets called again to get the value of <code class="literal">a</code> and <code class="literal">b</code>.</p></li></ul></div><p>
    </p><p>
      The trick is that <code class="literal">c</code> is not needed to be evaluated in the inner call, thus it doesn't go in an infinite loop.
    </p><p>
      Won't go further with the explanation here. A good post about fixed point and Nix can be <a class="link" href="http://r6.ca/blog/20140422T142911Z.html" target="_top">found here</a>.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737319669440"></a>17.3.1. Overriding a set with fixed point</h3></div></div></div><p>
        Given that <code class="literal">self.a</code> and <code class="literal">self.b</code> refer to the passed set and not to the literal set in the function, we're able to override both <code class="literal">a</code> and <code class="literal">b</code> and get a new value for <code class="literal">c</code>:
      </p><pre class="screen">nix-repl&gt; overrides = { a = 1; b = 2; }
nix-repl&gt; let newpkgs = pkgs (newpkgs // overrides); in newpkgs
{ a = 3; b = 4; c = 3; }
nix-repl&gt; let newpkgs = pkgs (newpkgs // overrides); in newpkgs // overrides
{ a = 1; b = 2; c = 3; }
</pre><p>
        In the first case we computed pkgs with the overrides, in the second case we also included the overriden attributes in the result.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319664480"></a>17.4. Overriding nixpkgs packages</h2></div></div></div><p>
      We've seen how to override attributes in a set such that they get recursively picked by dependant attributes. This approach can be used for derivations too, after all <code class="literal">nixpkgs</code> is a giant set of attributes that depend on each other.
    </p><p>
      To do this, <code class="literal">nixpkgs</code> offers <code class="literal">config.packageOverrides</code>. So <code class="literal">nixpkgs</code> returns a fixed point of the package set, and <code class="literal">packageOverrides</code> is used to inject the overrides.
    </p><p>
      Create a <code class="filename">config.nix</code> file like this somewhere:
    </p><pre class="screen">{
  packageOverrides = pkgs: {
    graphviz = pkgs.graphviz.override { xorg = null; };
  };
}
</pre><p>
      Now we can build e.g. <span class="package">asciidocFull</span> and it will automatically use the overridden <span class="package">graphviz</span>:
    </p><pre class="screen">nix-repl&gt; pkgs = import &lt;nixpkgs&gt; { config = import ./config.nix; }
nix-repl&gt; :b pkgs.asciidocFull
</pre><p>
      Note how we pass the <code class="literal">config</code> with <code class="literal">packageOverrides</code> when importing <code class="literal">nixpkgs</code>. Then <code class="literal">pkgs.asciidocFull</code> is a derivation that has <span class="package">graphviz</span> input (<code class="literal">pkgs.asciidoc</code> is the lighter version and doesn't use <span class="package">graphviz</span> at all).
    </p><p>
      Since there's no version of <span class="package">asciidoc</span> with <span class="package">graphviz</span> without X support in the binary cache, Nix will recompile the needed stuff for you.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319651952"></a>17.5. The ~/.nixpkgs/config.nix file</h2></div></div></div><p>
      In the previous pill we already talked about this file. The above <code class="filename">config.nix</code> that we just wrote could be the content of <code class="filename">~/.nixpkgs/config.nix</code>.
    </p><p>
      Instead of passing it explicitly whenever we import <code class="literal">nixpkgs</code>, it will be automatically <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/all-packages.nix#L54" target="_top">imported by nixpkgs</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319648112"></a>17.6. Conclusion</h2></div></div></div><p>
      We've learned about a new design pattern: using fixed point for overriding packages in a package set.
    </p><p>
      Whereas in an imperative setting, like with other package managers, a library is installed replacing the old version and applications will use it, in Nix it's not that straight and simple. But it's more precise.
    </p><p>
      Nix applications will depend on specific versions of libraries, hence the reason why we have to recompile <span class="package">asciidoc</span> to use the new <span class="package">graphviz</span> library.
    </p><p>
      The newly built <span class="package">asciidoc</span> will depend on the new <span class="package">graphviz</span>, and old <span class="package">asciidoc</span> will keep using the old <span class="package">graphviz</span> undisturbed.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319642528"></a>17.7. Next pill</h2></div></div></div><p>
      ...we will stop diving <code class="literal">nixpkgs</code> for a moment and talk about store paths. How does Nix compute the path in the store where to place the result of builds? How to add files to the store for which we have an integrity hash?
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="nixpkgs-parameters.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="nix-store-paths.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 16. Nixpkgs Parameters </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 18. Nix Store Paths</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 18. Nix Store Paths</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="nixpkgs-overriding-packages.html" title="Chapter 17. Nixpkgs Overriding Packages" /><link rel="next" href="fundamentals-of-stdenv.html" title="Chapter 19. Fundamentals of Stdenv" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 18. Nix Store Paths</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="nixpkgs-overriding-packages.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="fundamentals-of-stdenv.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="nix-store-paths"></a>Chapter 18. Nix Store Paths</h1></div></div></div><p>
    Welcome to the 18th Nix pill. In the previous <a class="link" href="nixpkgs-overriding-packages.html" title="Chapter 17. Nixpkgs Overriding Packages">17th</a> pill we have scratched the surface of the <code class="literal">nixpkgs</code> repository structure. It is a set of packages, and it's possible to override such packages so that all other packages will use the overrides.
  </p><p>
    Before reading existing derivations, I'd like to talk about store paths and how they are computed. In particular we are interested in fixed store paths that depend on an integrity hash (e.g. a sha256), which is usually applied to source tarballs.
  </p><p>
    The way store paths are computed is a little contrived, mostly due to historical reasons. Our reference will be the <a class="link" href="https://github.com/NixOS/nix/blob/07f992a74b64f4376d5b415d0042babc924772f3/src/libstore/store-api.cc#L197" target="_top">Nix source code</a>.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319634688"></a>18.1. Source paths</h2></div></div></div><p>
      Let's start simple. You know nix allows relative paths to be used, such that the file or directory is stored in the nix store, that is <code class="filename">./myfile</code> gets stored into <code class="filename">/nix/store/.......</code> We want to understand how is the store path generated for such a file:
    </p><pre class="screen">$ echo mycontent &gt; myfile</pre><p>
      I remind you, the simplest derivation you can write has a <code class="literal">name</code>, a <code class="literal">builder</code> and the <code class="literal">system</code>:
    </p><pre class="screen">$ nix repl
nix-repl&gt; derivation { system = "x86_64-linux"; builder = ./myfile; name = "foo"; }
«derivation /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv»
</pre><p>
      Now inspect the .drv to see where is <code class="filename">./myfile</code> being stored:
    </p><pre class="screen"><code class="prompt">$ </code><strong class="userinput"><code>nix show-derivation /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-<span class="emphasis"><em>foo.drv</em></span></code></strong>
<code class="computeroutput">{
  "/nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo"
      }
    },
    "inputSrcs": [
      "/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile"
    ],
    "inputDrvs": {},
    "platform": "x86_64-linux",
    "builder": "/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile",
    "args": [],
    "env": {
      "builder": "/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile",
      "name": "foo",
      "out": "/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo",
      "system": "x86_64-linux"
    }
  }
}</code></pre><p>
      Great, how did nix decide to use <code class="literal">xv2iccirbrvklck36f1g7vldn5v58vck</code> ? Keep looking at the nix comments.
    </p><p>
      <span class="bold"><strong>Note:</strong></span> doing <span class="command"><strong>nix-store --add myfile</strong></span> will store the file in the same store path.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737319624288"></a>18.1.1. Step 1, compute the hash of the file</h3></div></div></div><p>
        The comments tell us to first compute the sha256 of the NAR serialization of the file. Can be done in two ways:
      </p><pre class="screen">$ nix-hash --type sha256 myfile
2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3
</pre><p>
        Or:
      </p><pre class="screen">$ nix-store --dump myfile|sha256sum
2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3
</pre><p>
        In general, Nix understands two contents: flat for regular files, or recursive for NAR serializations which can be anything.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737319620992"></a>18.1.2. Step 2, build the string description</h3></div></div></div><p>
        Then nix uses a special string which includes the hash, the path type and the file name. We store this in another file:
      </p><pre class="screen">$ echo -n "source:sha256:2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3:/nix/store:myfile" &gt; myfile.str</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737319619024"></a>18.1.3. Step 3, compute the final hash</h3></div></div></div><p>
        Finally the comments tell us to compute the base-32 representation of the first 160 bits (truncation) of a sha256 of the above string:
      </p><pre class="screen">$ nix-hash --type sha256 --truncate --base32 --flat myfile.str
xv2iccirbrvklck36f1g7vldn5v58vck
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319617040"></a>18.2. Output paths</h2></div></div></div><p>
      Output paths are usually generated for derivations. We use the above example because it's simple. Even if we didn't build the derivation, nix knows the out path <code class="literal">hs0yi5n5nw6micqhy8l1igkbhqdkzqa1</code>. This is because the out path only depends on inputs.
    </p><p>
      It's computed in a similar way to source paths, except that the .drv is hashed and the type of derivation is <code class="literal">output:out</code>. In case of multiple outputs, we may have different <code class="literal">output:&lt;id&gt;</code>.
    </p><p>
      At the time nix computes the out path, the .drv contains an empty string for each out path. So what we do is getting our .drv and replacing the out path with an empty string:
    </p><pre class="screen">$ cp -f /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv myout.drv
$ sed -i 's,/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo,,g' myout.drv
</pre><p>
      The <code class="literal">myout.drv</code> is the .drv state in which nix is when computing the out path for our derivation:
    </p><pre class="screen">$ sha256sum myout.drv
1bdc41b9649a0d59f270a92d69ce6b5af0bc82b46cb9d9441ebc6620665f40b5  myout.drv
$ echo -n "output:out:sha256:1bdc41b9649a0d59f270a92d69ce6b5af0bc82b46cb9d9441ebc6620665f40b5:/nix/store:foo" &gt; myout.str
$ nix-hash --type sha256 --truncate --base32 --flat myout.str
hs0yi5n5nw6micqhy8l1igkbhqdkzqa1
</pre><p>
      Then nix puts that out path in the .drv, and that's it.
    </p><p>
      In case the .drv has input derivations, that is it references other .drv, then such .drv paths are replaced by this same algorithm which returns a hash.
    </p><p>
      In other words, you get a final .drv where every other .drv path is replaced by its hash.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319609408"></a>18.3. Fixed-output paths</h2></div></div></div><p>
      Finally, the other most used kind of path is when we know beforehand an integrity hash of a file. This is usual for tarballs.
    </p><p>
      A derivation can take three special attributes: <code class="literal">outputHashMode</code>, <code class="literal">outputHash</code> and <code class="literal">outputHashAlgo</code> which are well documented in the <a class="link" href="https://nixos.org/nix/manual/#sec-advanced-attributes" target="_top">nix manual</a>.
    </p><p>
      The builder must create the out path and make sure its hash is the same as the one declared with <code class="literal">outputHash</code>.
    </p><p>
      Let's say our builder should create a file whose contents is <code class="literal">mycontent</code>:
    </p><pre class="screen">$ echo mycontent &gt; myfile
$ sha256sum myfile
f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb  myfile
nix-repl&gt; derivation { name = "bar"; system = "x86_64-linux"; builder = "none"; outputHashMode = "flat"; outputHashAlgo = "sha256"; outputHash = "f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb"; }
«derivation /nix/store/ymsf5zcqr9wlkkqdjwhqllgwa97rff5i-bar.drv»
</pre><p>
      Inspect the .drv and see that it also stored the fact that it's a fixed-output derivation with sha256 algorithm, compared to the previous examples:
    </p><pre class="screen"><code class="prompt">$ </code><strong class="userinput"><code>nix show-derivation /nix/store/ymsf5zcqr9wlkkqdjwhqllgwa97rff5i-<span class="emphasis"><em>bar.drv</em></span></code></strong>
<code class="computeroutput">{
  "/nix/store/ymsf5zcqr9wlkkqdjwhqllgwa97rff5i-bar.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/a00d5f71k0vp5a6klkls0mvr1f7sx6ch-bar",
        "hashAlgo": "sha256",
        "hash": "f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb"
      }
    },
<span class="emphasis"><em>[...]</em></span>
}</code></pre><p>
      It doesn't matter which input derivations are being used, the final out path must only depend on the declared hash.
    </p><p>
      What nix does is to create an intermediate string representation of the fixed-output content:
    </p><pre class="screen">$ echo -n "fixed:out:sha256:f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb:" &gt; mycontent.str
$ sha256sum mycontent.str
423e6fdef56d53251c5939359c375bf21ea07aaa8d89ca5798fb374dbcfd7639  myfile.str

</pre><p>
      Then proceed as it was a normal derivation output path:
    </p><pre class="screen">$ echo -n "output:out:sha256:423e6fdef56d53251c5939359c375bf21ea07aaa8d89ca5798fb374dbcfd7639:/nix/store:bar" &gt; myfile.str
$ nix-hash --type sha256 --truncate --base32 --flat myfile.str
a00d5f71k0vp5a6klkls0mvr1f7sx6ch
</pre><p>
      Hence, the store path only depends on the declared fixed-output hash.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319595456"></a>18.4. Conclusion</h2></div></div></div><p>
      There are other types of store paths, but you get the idea. Nix first hashes the contents, then creates a string description, and the final store path is the hash of this string.
    </p><p>
      Also we've introduced some fundamentals, in particular the fact that Nix knows beforehand the out path of a derivation since it only depends on the inputs. We've also introduced fixed-output derivations which are especially used by the nixpkgs repository for downloading and verifying source tarballs.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319593344"></a>18.5. Next pill</h2></div></div></div><p>
      ...we will introduce <code class="literal">stdenv</code>. In the previous pills we rolled our own <code class="literal">mkDerivation</code> convenience function for wrapping the builtin derivation, but the <code class="literal">nixpkgs</code> repository also has its own convenience functions for dealing with <span class="package">autotools</span> projects and other build systems.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="nixpkgs-overriding-packages.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="fundamentals-of-stdenv.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 17. Nixpkgs Overriding Packages </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 19. Fundamentals of Stdenv</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 19. Fundamentals of Stdenv</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="nix-store-paths.html" title="Chapter 18. Nix Store Paths" /><link rel="next" href="basic-dependencies-and-hooks.html" title="Chapter 20. Basic Dependencies and Hooks" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 19. Fundamentals of Stdenv</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="nix-store-paths.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="basic-dependencies-and-hooks.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="fundamentals-of-stdenv"></a>Chapter 19. Fundamentals of Stdenv</h1></div></div></div><p>
    Welcome to the 19th Nix pill. In the previous <a class="link" href="nix-store-paths.html" title="Chapter 18. Nix Store Paths">18th</a> pill we did dive into the algorithm used by Nix to compute the store paths, and also introduced fixed-output store paths.
  </p><p>
    This time we will instead look into <code class="literal">nixpkgs</code>, in particular one of its core derivation: <code class="literal">stdenv</code>.
  </p><p>
    The <code class="literal">stdenv</code> is not a special derivation to Nix, but it's very important for the <code class="literal">nixpkgs</code> repository. It serves as base for packaging software. It is used to pull in dependencies such as the GCC toolchain, GNU make, core utilities, patch and diff utilities, and so on. Basic tools needed to compile a huge pile of software currently present in <code class="literal">nixpkgs</code>.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319583280"></a>19.1. What is stdenv</h2></div></div></div><p>
      First of all <code class="literal">stdenv</code> is a derivation. And it's a very simple one:
    </p><pre class="screen">$ nix-build '&lt;nixpkgs&gt;' -A stdenv
/nix/store/k4jklkcag4zq4xkqhkpy156mgfm34ipn-stdenv
$ ls -R result/
result/:
nix-support/  setup

result/nix-support:
propagated-user-env-packages
</pre><p>
      It has just two files: <code class="filename">/setup</code> and <code class="filename">/nix-support/propagated-user-env-packages</code>. Don't care about the latter; it's empty, in fact. The important file is <code class="filename">/setup</code>.
    </p><p>
      How can this simple derivation pull in all the toolchain and basic tools needed to compile packages? Let's look at the runtime dependencies:
    </p><pre class="screen">$ nix-store -q --references result
/nix/store/3a45nb37s0ndljp68228snsqr3qsyp96-bzip2-1.0.6
/nix/store/a457ywa1haa0sgr9g7a1pgldrg3s798d-coreutils-8.24
/nix/store/zmd4jk4db5lgxb8l93mhkvr3x92g2sx2-bash-4.3-p39
/nix/store/47sfpm2qclpqvrzijizimk4md1739b1b-gcc-wrapper-4.9.3
...
</pre><p>
      How can it be? The package must be referring to those package somehow. In fact, they are hardcoded in the <code class="filename">/setup</code> file:
    </p><pre class="screen">$ head result/setup
export SHELL=/nix/store/zmd4jk4db5lgxb8l93mhkvr3x92g2sx2-bash-4.3-p39/bin/bash
initialPath="/nix/store/a457ywa1haa0sgr9g7a1pgldrg3s798d-coreutils-8.24 ..."
defaultNativeBuildInputs="/nix/store/sgwq15xg00xnm435gjicspm048rqg9y6-patchelf-0.8 ..."

</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319576176"></a>19.2. The setup file</h2></div></div></div><p>
      Remember our generic <code class="filename">builder.sh</code> in <a class="link" href="generic-builders.html" title="Chapter 8. Generic Builders">Pill 8</a>? It sets up a basic <code class="varname">PATH</code>, unpacks the source and runs the usual <span class="package">autotools</span> commands for us.
    </p><p>
      The <code class="literal">stdenv</code> <code class="filename">setup</code> file is exactly that. It sets up several environment variables like <code class="varname">PATH</code> and creates some helper bash functions to build a package. I invite you to read it, it's only 860 lines at the time of this writing.
    </p><p>
      The hardcoded toolchain and utilities are used to initially fill up the environment variables so that it's more pleasant to run common commands, similar to what we did with our builder with <code class="literal">baseInputs</code> and <code class="literal">buildInputs</code>.
    </p><p>
      The build with <code class="literal">stdenv</code> works in phases. Phases are like <code class="literal">unpackPhase</code>, <code class="literal">configurePhase</code>, <code class="literal">buildPhase</code>, <code class="literal">checkPhase</code>, <code class="literal">installPhase</code>, <code class="literal">fixupPhase</code>. You can see the default list in the <code class="literal">genericBuild</code> function.
    </p><p>
      What <code class="literal">genericBuild</code> does is just run these phases. Default phases are just bash functions, you can easily read them.
    </p><p>
      Every phase has hooks to run commands before and after the phase has been executed.
      Phases can be overwritten, reordered, whatever, it's just bash code.
    </p><p>
      How to use this file? Like our old builder. To test it, we enter a fake empty derivation, source the <code class="literal">stdenv</code> <code class="filename">setup</code>, unpack the hello sources and build it:
    </p><pre class="screen">$ nix-shell -E 'derivation { name = "fake"; builder = "fake"; system = "x86_64-linux"; }'
nix-shell$ unset PATH
nix-shell$ source /nix/store/k4jklkcag4zq4xkqhkpy156mgfm34ipn-stdenv/setup
nix-shell$ tar -xf hello-2.10.tar.gz
nix-shell$ cd hello-2.10
nix-shell$ configurePhase
...
nix-shell$ buildPhase
...
</pre><p>
      <span class="italic">I unset <code class="varname">PATH</code> to further show that the <code class="literal">stdenv</code> is enough self-contained to build autotools packages that have no other dependencies.</span>
    </p><p>
      So we ran the <code class="literal">configurePhase</code> function and <code class="literal">buildPhase</code> function and they worked. These bash functions should be self-explanatory, you can read the code in the <code class="filename">setup</code> file.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319558048"></a>19.3. How is the setup file built</h2></div></div></div><p>
      Until now we worked with plain bash scripts. What about the Nix side? The <code class="literal">nixpkgs</code> repository offers a useful function, like we did with our old builder. It is a wrapper around the raw derivation function which pulls in the <code class="literal">stdenv</code> for us, and runs <code class="literal">genericBuild</code>. It's <code class="literal">stdenv.mkDerivation</code>.
    </p><p>
      Note how <code class="literal">stdenv</code> is a derivation but it's also an attribute set which contains some other attributes, like <code class="literal">mkDerivation</code>. Nothing fancy here, just convenience.
    </p><p>
      Let's write a <code class="filename">hello.nix</code> expression using this new discovered <code class="literal">stdenv</code>:
    </p><pre class="screen">with import &lt;nixpkgs&gt; {};
stdenv.mkDerivation {
  name = "hello";
  src = ./hello-2.10.tar.gz;
}
</pre><p>
      Don't be scared by the <code class="literal">with</code> expression. It pulls the <code class="literal">nixpkgs</code> repository into scope, so we can directly use <code class="literal">stdenv</code>. It looks very similar to the hello expression in <a class="link" href="generic-builders.html" title="Chapter 8. Generic Builders">Pill 8</a>.
    </p><p>
      It builds, and runs fine:
    </p><pre class="screen">$ nix-build hello.nix
...
/nix/store/6y0mzdarm5qxfafvn2zm9nr01d1j0a72-hello
$ result/bin/hello
Hello, world!
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319547952"></a>19.4. The stdenv.mkDerivation builder</h2></div></div></div><p>
      Let's take a look at the builder used by <code class="literal">mkDerivation</code>. You can read the code <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/make-derivation.nix" target="_top">here in nixpkgs</a>:
    </p><pre class="screen">{
  ...
  builder = attrs.realBuilder or shell;
  args = attrs.args or ["-e" (attrs.builder or ./default-builder.sh)];
  stdenv = result;
  ...
}
</pre><p>
      Also take a look at our old derivation wrapper in previous pills! The builder is bash (that shell variable), the argument to the builder (bash) is <code class="filename">default-builder.sh</code>, and then we add the environment variable <code class="literal">$stdenv</code> in the derivation which is the <code class="literal">stdenv</code> derivation.
    </p><p>
      You can open <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/default-builder.sh" target="_top">default-builder.sh</a> and see what it does:
    </p><pre class="screen">source $stdenv/setup
genericBuild
</pre><p>
      It's what we did in <a class="link" href="developing-with-nix-shell.html" title="Chapter 10. Developing with nix-shell">Pill 10</a> to make the derivations <code class="literal">nix-shell</code> friendly. When entering the shell, the setup file only sets up the environment without building anything. When doing <code class="literal">nix-build</code>, it actually runs the build process.
    </p><p>
      To get a clear understanding of the environment variables, look at the .drv of the hello derivation:
    </p><pre class="screen"><code class="prompt">$ </code><strong class="userinput"><code>nix show-derivation $(nix-instantiate hello.nix)</code></strong>
<code class="computeroutput">warning: you did not specify '--add-root'; the result might be removed by the garbage collector
{
  "/nix/store/abwj50lycl0m515yblnrvwyydlhhqvj2-hello.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/6y0mzdarm5qxfafvn2zm9nr01d1j0a72-hello"
      }
    },
    "inputSrcs": [
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh",
      "/nix/store/svc70mmzrlgq42m9acs0prsmci7ksh6h-hello-2.10.tar.gz"
    ],
    "inputDrvs": {
      "/nix/store/hcgwbx42mcxr7ksnv0i1fg7kw6jvxshb-bash-4.4-p19.drv": [
        "out"
      ],
      "/nix/store/sfxh3ybqh97cgl4s59nrpi78kgcc8f3d-stdenv-linux.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
    "args": [
      "-e",
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "env": {
      "buildInputs": "",
      "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
      "configureFlags": "",
      "depsBuildBuild": "",
      "depsBuildBuildPropagated": "",
      "depsBuildTarget": "",
      "depsBuildTargetPropagated": "",
      "depsHostBuild": "",
      "depsHostBuildPropagated": "",
      "depsTargetTarget": "",
      "depsTargetTargetPropagated": "",
      "name": "hello",
      "nativeBuildInputs": "",
      "out": "/nix/store/6y0mzdarm5qxfafvn2zm9nr01d1j0a72-hello",
      "propagatedBuildInputs": "",
      "propagatedNativeBuildInputs": "",
      "src": "/nix/store/svc70mmzrlgq42m9acs0prsmci7ksh6h-hello-2.10.tar.gz",
      "stdenv": "/nix/store/6kz2vbh98s2r1pfshidkzhiy2s2qdw0a-stdenv-linux",
      "system": "x86_64-linux"
    }
  }
}</code></pre><p>
      So short I decided to paste it entirely above. The builder is bash, with <code class="literal">-e default-builder.sh</code> arguments. Then you can see the <code class="literal">src</code> and <code class="literal">stdenv</code> environment variables.
    </p><p>
      Last bit, the <code class="literal">unpackPhase</code> in the setup is used to unpack the sources and enter the directory, again like we did in our old builder.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319532480"></a>19.5. Conclusion</h2></div></div></div><p>
      The <code class="literal">stdenv</code> is the core of the <code class="literal">nixpkgs</code> repository. All packages use the <code class="literal">stdenv.mkDerivation</code> wrapper instead of the raw derivation. It does a bunch of operations for us and also sets up a pleasant build environment.
    </p><p>
      The overall process is simple:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>nix-build</strong></span></p></li><li class="listitem"><p><span class="command"><strong>bash -e default-builder.sh</strong></span></p></li><li class="listitem"><p><span class="command"><strong>source $stdenv/setup</strong></span></p></li><li class="listitem"><p><span class="command"><strong>genericBuild</strong></span></p></li></ul></div><p>
    </p><p>
      That's it, everything you need to know about the stdenv phases is in the <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh" target="_top">setup file</a>.
    </p><p>
      Really, take your time to read that file. Don't forget that juicy docs are also available in the <a class="link" href="http://nixos.org/nixpkgs/manual/#chap-stdenv" target="_top">nixpkgs manual</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319523728"></a>19.6. Next pill...</h2></div></div></div><p>
      ...we will talk about how to add dependencies to our packages with <code class="literal">buildInputs</code> and <code class="literal">propagatedBuildInputs</code>, and influence downstream builds with <em class="firstterm">setup hooks</em> and <em class="firstterm">env hooks</em>.
      These concepts are crucial to how <code class="literal">nixpkgs</code> packages are composed.
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="nix-store-paths.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="basic-dependencies-and-hooks.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 18. Nix Store Paths </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 20. Basic Dependencies and Hooks</td></tr></table></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 20. Basic Dependencies and Hooks</title><link rel="stylesheet" type="text/css" href="style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.2" /><link rel="home" href="index.html" title="Nix Pills" /><link rel="up" href="index.html" title="Nix Pills" /><link rel="prev" href="fundamentals-of-stdenv.html" title="Chapter 19. Fundamentals of Stdenv" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 20. Basic Dependencies and Hooks</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="fundamentals-of-stdenv.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="basic-dependencies-and-hooks"></a>Chapter 20. Basic Dependencies and Hooks</h1></div></div></div><p>
    Welcome to the 20th Nix pill.
    In the previous <a class="link" href="fundamentals-of-stdenv.html" title="Chapter 19. Fundamentals of Stdenv">19th</a> pill we introduced Nixpkgs' stdenv, including <code class="filename">setup.sh</code> script, <code class="filename">default-builder.sh</code> helper script, and <code class="literal">stdenv.mkDerivation</code> builder.
    We focused on how stdenv is put together, and how it's used, and a bit about the phases of <code class="function">genericBuild</code>.
  </p><p>
    This time, we'll focus on the interaction of packages built with <code class="literal">stdenv.mkDerivation</code>.
    Packages need to depend on each other, of course.
    For this we have <code class="varname">buildInputs</code> and <code class="varname">propagatedBuildInputs</code> attributes.
    We've also found that dependencies sometimes need to influence their dependents in ways the dependents can't or shouldn't predict.
    For this we have <em class="firstterm">setup hooks</em> and <em class="firstterm">env hooks</em>.
    Together, these 4 concepts support almost all build-time package interactions.
  </p><div class="note"><h3 class="title">Note</h3><p>
    The complexity of the dependencies and hooks infrastructure has increased, over time, to support cross compilation.
    Once you learn the core concepts, you will be able to understand the extra complexity.
    As a starting point, you might want to refer to nixpkgs commit <a class="link" href="https://github.com/nixos/nixpkgs/tree/6675f0a52c0962042a1000c7f20e887d0d26ae25" target="_top">6675f0a5</a>, the last version of stdenv without cross-compilation complexity.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319510272"></a>20.1. The <code class="varname">buildInputs</code> Attribute</h2></div></div></div><p>
      For the simplest dependencies where the current package directly needs another, we use the <code class="varname">buildInputs</code> attribute.
      This is exactly the pattern in taught with our builder in <a class="link" href="generic-builders.html" title="Chapter 8. Generic Builders">Pill 8</a>.
      To demo this, lets build GNU Hello, and then another package which provides a shell script that <span class="command"><strong>exec</strong></span>s it.
      </p><pre class="screen">let

  nixpkgs = import &lt;nixpkgs&gt; {};

  inherit (nixpkgs) stdenv fetchurl which;

  actualHello = stdenv.mkDerivation {
    name = "hello-2.3";

    src = fetchurl {
      url = mirror://gnu/hello/hello-2.3.tar.bz2;
      sha256 = "0c7vijq8y68bpr7g6dh1gny0bff8qq81vnp4ch8pjzvg56wb3js1";
    };
  };

  wrappedHello = stdenv.mkDerivation {
    name = "hello-wrapper";

    buildInputs = [ actualHello which ];

    unpackPhase = "true";

    installPhase = ''
      mkdir -p "$out/bin"
      echo "#! ${stdenv.shell}" &gt;&gt; "$out/bin/hello"
      echo "exec $(which hello)" &gt;&gt; "$out/bin/hello"
    '';
  };

in wrappedHello
</pre><p>
    </p><p>
      Notice that the wrappedHello derivation finds the <span class="command"><strong>hello</strong></span> binary from the <code class="envar">PATH</code>.
      This works because stdenv contains something like:
      </p><pre class="screen">pkgs=""
for i in $buildInputs; do
    findInputs $i
done
</pre><p>
      where <code class="function">findInputs</code> is defined like:
      </p><pre class="screen">findInputs() {
    local pkg=$1

    ## Don't need to repeat already processed package
    case $pkgs in
        *\ $pkg\ *)
            return 0
            ;;
    esac

    pkgs="$pkgs $pkg "

    ## More goes here in reality that we can ignore for now.
}
</pre><p>
      then after this is run:
      </p><pre class="screen">for i in $pkgs; do
    addToEnv $i
done
</pre><p>
      where <code class="function">addToEnv</code> is defined like:
      </p><pre class="screen">addToEnv() {
    local pkg=$1

    if test -d $1/bin; then
        addToSearchPath _PATH $1/bin
    fi

    ## More goes here in reality that we can ignore for now.
}
</pre><p>

      The <code class="function">addToSearchPath</code> call adds <code class="literal">$1/bin</code> to <code class="envar">_PATH</code> if the former exists (code <a class="link" href="https://github.com/NixOS/nixpkgs/blob/6675f0a52c0962042a1000c7f20e887d0d26ae25/pkgs/stdenv/generic/setup.sh#L60-L73" target="_top">here</a>).
      Once all the packages in <code class="varname">buildInputs</code> have been processed, then content of <code class="envar">_PATH</code> is added to <code class="envar">PATH</code>, as follows:
      </p><pre class="screen">PATH="${_PATH-}${_PATH:+${PATH:+:}}$PATH"
</pre><p>

      With the real <span class="command"><strong>hello</strong></span> on the <code class="envar">PATH</code>, the <code class="function">installPhase</code> should hopefully make sense.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319495280"></a>20.2. The <code class="varname">propagatedBuildInputs</code> Attribute</h2></div></div></div><p>
      The <code class="varname">buildInputs</code> covers direct dependencies, but what about indirect dependencies where one package needs a second package which needs a third?
      Nix itself handles this just fine, understanding various dependency <em class="firstterm">closures</em> as covered in previous builds.
      But what about the conveniences that <code class="varname">buildInputs</code> provides, namely accumulating in <code class="envar">pkgs</code> environment variable and inclusion of <code class="filename"><em class="replaceable"><code>pkg</code></em>/bin</code> directories on the <code class="envar">PATH</code>?
      For this, stdenv provides the <code class="varname">propagatedBuildInputs</code>:
      </p><pre class="screen">let

  nixpkgs = import &lt;nixpkgs&gt; {};

  inherit (nixpkgs) stdenv fetchurl which;

  actualHello = stdenv.mkDerivation {
    name = "hello-2.3";

    src = fetchurl {
      url = mirror://gnu/hello/hello-2.3.tar.bz2;
      sha256 = "0c7vijq8y68bpr7g6dh1gny0bff8qq81vnp4ch8pjzvg56wb3js1";
    };
  };

  intermediary = stdenv.mkDerivation {
    name = "middle-man";

    propagatedBuildInputs = [ actualHello ];

    unpackPhase = "true";

    installPhase = ''
      mkdir -p "$out"
    '';
  };

  wrappedHello = stdenv.mkDerivation {
    name = "hello-wrapper";

    buildInputs = [ intermediary which ];

    unpackPhase = "true";

    installPhase = ''
      mkdir -p "$out/bin"
      echo "#! ${stdenv.shell}" &gt;&gt; "$out/bin/hello"
      echo "exec $(which hello)" &gt;&gt; "$out/bin/hello"
    '';
  };

in wrappedHello
</pre><p>
      See how the intermediate package has a <code class="varname">propagatedBuildInputs</code> dependency, but the wrapper only needs a <code class="varname">buildInputs</code> dependency on the intermediary.
    </p><p>
      How does this work?
      You might think we do something in Nix, but actually its done not at eval time but at build time in bash.
      lets look at part of the <code class="function">fixupPhase</code> of stdenv:

      </p><pre class="screen">fixupPhase() {

    ## Elided

    if test -n "$propagatedBuildInputs"; then
        mkdir -p "$out/nix-support"
        echo "$propagatedBuildInputs" &gt; "$out/nix-support/propagated-build-inputs"
    fi

    ## Elided

}
</pre><p>

      This dumps the propagated build inputs in a so-named file in <code class="filename">$out/nix-support/</code>.
      Then, back in <code class="function">findInputs</code> look at the lines at the bottom we elided before:

      </p><pre class="screen">findInputs() {
    local pkg=$1

    ## More goes here in reality that we can ignore for now.

    if test -f $pkg/nix-support/propagated-build-inputs; then
        for i in $(cat $pkg/nix-support/propagated-build-inputs); do
            findInputs $i
        done
    fi
}
</pre><p>

      See how <code class="function">findInputs</code> is actually recursive, looking at the propagated build inputs of each dependency, and those dependencies' propagated build inputs, etc.
    </p><p>
      We actually simplified the <code class="function">findInputs</code> call site from before; <code class="envar">propagatedBuildInputs</code> is also looped over in reality:
      </p><pre class="screen">pkgs=""
for i in $buildInputs $propagatedBuildInputs; do
    findInputs $i
done
</pre><p>
      This demonstrates an important point. For the <span class="emphasis"><em>current</em></span> package alone, it doesn't matter whether a dependency is propagated or not.
      It will be processed the same way: called with <code class="function">findInputs</code> and <code class="function">addToEnv</code>.
      (The packages discovered by <code class="function">findInputs</code>, which are also accumulated in <code class="envar">pkgs</code> and passed to <code class="function">addToEnv</code>, are also the same in both cases.)
      Downstream however, it certainly does matter because only the propagated immediate dependencies are put in the <code class="filename">$out/nix-support/propagated-build-inputs</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319477648"></a>20.3. Setup Hooks</h2></div></div></div><p>
      As we mentioned above, sometimes dependencies need to influence the packages that use them in ways other than just <span class="emphasis"><em>being</em></span> a dependency.

      <a href="#ftn.idm140737319476080" class="footnote" id="idm140737319476080"><sup class="footnote">[1]</sup></a>

      <code class="varname">propagatedBuildInputs</code> can actually be seen as an example of this:
      packages using that are effectively "injecting" those dependencies as extra <code class="varname">buildInputs</code> in their downstream dependents.

      But in general, a dependency might affect the packages it depends on in arbitrary ways.
      <span class="emphasis"><em>Arbitrary</em></span> is the key word here.
      We could teach <code class="filename">setup.sh</code> things about upstream packages like <code class="filename"><em class="replaceable"><code>pkg</code></em>/nix-support/propagated-build-inputs</code>, but not arbitrary interactions.
    </p><p>
      <em class="firstterm">Setup hooks</em> are the basic building block we have for this.
      In nixpkgs, a "hook" is basically a bash callback, and a setup hook is no exception.
      Let's look at the last part of <code class="function">findInputs</code> we haven't covered:
      </p><pre class="screen">findInputs() {
    local pkg=$1

    ## More goes here in reality that we can ignore for now.

    if test -f $pkg/nix-support/setup-hook; then
        source $pkg/nix-support/setup-hook
    fi

    ## More goes here in reality that we can ignore for now.

}
</pre><p>
      If a package includes the path <code class="filename"><em class="replaceable"><code>pkg</code></em>/nix-support/setup-hook</code>, it will be sourced by any stdenv-based build including that as a dependency.
    </p><p>
      This is strictly more general than any of the other mechanisms introduced in this chapter.
      For example, try writing a setup hook that has the same effect as a <span class="emphasis"><em>propagatedBuildInputs</em></span> entry.
      One can almost think of this as an escape hatch around Nix's normal isolation guarantees, and the principle that dependencies are immutable and inert.
      We're not actually doing something unsafe or modifying dependencies, but we are allowing arbitrary ad-hoc behavior.
      For this reason, setup-hooks should only be used as a last resort.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319466016"></a>20.4. Environment Hooks</h2></div></div></div><p>
      As a final convenience, we have environment hooks.
      Recall in <a class="link" href="inputs-design-pattern.html" title="Chapter 12. Inputs Design Pattern">Pill 12</a> how we created <code class="envar">NIX_CFLAGS_COMPILE</code> for <code class="literal">-I</code> flags and <code class="envar">NIX_LDFLAGS</code> for <code class="literal">-L</code> flags, in a similar manner to how we prepared the <code class="envar">PATH</code>.
      One point of ugliness was how anti-modular this was.
      It makes sense to build the <code class="envar">PATH</code> in generic builder, because the <code class="envar">PATH</code> is used by the shell, and the generic builder is intrinsically tied to the shell.
      But <code class="literal">-I</code> and <code class="literal">-L</code> flags are only relevant to the C compiler.
      The stdenv isn't wedded to including a C compiler (though it does by default), and there are other compilers too which may take completely different flags.
    </p><p>
      As a first step, we can move that logic to a setup hook on the C compiler;
      indeed that's just what we do in CC Wrapper.
      <a href="#ftn.idm140737319459424" class="footnote" id="idm140737319459424"><sup class="footnote">[2]</sup></a>
      But this pattern comes up fairly often, so somebody decided to add some helper support to reduce boilerplate.
    </p><p>
      The other half of <code class="function">addToEnv</code> is:
      </p><pre class="screen">addToEnv() {
    local pkg=$1

    ## More goes here in reality that we can ignore for now.

    # Run the package-specific hooks set by the setup-hook scripts.
    for i in "${envHooks[@]}"; do
        $i $pkg
    done
}
</pre><p>
      Functions listed in <code class="varname">envHooks</code> are applied to every package passed to <code class="function">addToEnv</code>.
      One can write a setup hook like:
      </p><pre class="screen">anEnvHook() {
    local pkg=$1

    echo "I'm depending on \"$pkg\""
}

envHooks+=(anEnvHook)
</pre><p>
      and if one dependency has that setup hook then all of them will be so <span class="command"><strong>echo</strong></span>ed.
      Allowing dependencies to learn about their <span class="emphasis"><em>sibling</em></span> dependencies is exactly what compilers need.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737319453200"></a>20.5. Next pill...</h2></div></div></div><p>
      ...I'm not sure!
      We could talk about the additional dependency types and hooks which cross compilation necessitates, building on our knowledge here to cover stdenv as it works today.
      We could talk about how nixpkgs is bootstrapped.
      Or we could talk about how <code class="varname">localSystem</code> and <code class="varname">crossSystem</code> are elaborated into the <code class="varname">buildPlatform</code>, <code class="varname">hostPlatform</code>, and <code class="varname">targetPlatform</code> each bootstrapping stage receives.
      Let us know which most interests you!
    </p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm140737319476080" class="footnote"><p><a href="#idm140737319476080" class="para"><sup class="para">[1] </sup></a>
          We can now be precise and consider what <code class="function">addToEnv</code> does alone the minimal treatment of a dependency:
          i.e. a package that is <span class="emphasis"><em>just</em></span> a dependency would <span class="emphasis"><em>only</em></span> have <code class="function">addToEnv</code> applied to it.
        </p></div><div id="ftn.idm140737319459424" class="footnote"><p><a href="#idm140737319459424" class="para"><sup class="para">[2] </sup></a>
          It was called <a class="link" href="https://github.com/NixOS/nixpkgs/tree/6675f0a52c0962042a1000c7f20e887d0d26ae25/pkgs/build-support/gcc-wrapper" target="_top">GCC Wrapper</a> in the version of nixpkgs suggested for following along in this pill; Darwin and Clang support hadn't yet motivated the rename.
        </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fundamentals-of-stdenv.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">Chapter 19. Fundamentals of Stdenv </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>

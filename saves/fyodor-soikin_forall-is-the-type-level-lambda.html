<!DOCTYPE html>
<!-- saved from url=(0083)https://medium.com/collegevine-product/forall-is-the-type-level-lambda-9237b4ca6827 -->
<html lang="en" data-rh="lang"><body><div id="root"><div class="a b c"><article><section class="gg gh gi gj ai gk dp r"></section><span class="r"></span><div><div class="s u ww gm gn eu"></div><section class="go gp gq gr gs"><div class="n p"><div class="z ab ac ae af gt ah ai"><div><h1 id="3139" class="gu gv bq gw b gx gy gz ha hb hc hd he hf hg hh hi hj hk hl hm da">“forall” is the type-level “lambda”</h1><div class="hn"><div class="n fn ho hp hq"><div class="o n"><div class="ht ai r"><div class="n"><div style="flex:1"><span class="bp b bq br bs bt r da q"><div class="hu n o hv"><span class="bp hw ci br cc hx cb hy hz ia da"><a class="cn co bb bc bd be bf bg bh bi ib bl cr cs" rel="noopener" href="https://medium.com/@name.fa?source=post_page-----9237b4ca6827----------------------">Fyodor Soikin</a></span><div class="fx r bo h"><button class="ic db az ba id bj bk ie bi dm bp b bq if ig bt dn do dp ce dq">Follow</button></div></div></span></div></div><span class="bp b bq br bs bt r bu bv"><span class="bp hw ci br cc hx cb hy hz ia bu"><div><a class="cn co bb bc bd be bf bg bh bi ib bl cr cs" rel="noopener" href="https://medium.com/collegevine-product/forall-is-the-type-level-lambda-9237b4ca6827?source=post_page-----9237b4ca6827----------------------">Dec 27, 2018</a> <!-- -->·<!-- --> <!-- -->3<!-- --> min read</div></span></span></div></div></div></div></div><p id="e1ba" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">In Haskell we write:</p><pre class="jr js jt ju jv jw jx ee"><span id="c16f" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">mkList :: a -&gt; [a]</span></pre><p id="5c7b" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">But PureScript requires a seemingly extraneous bit in there:</p><pre class="jr js jt ju jv jw jx ee"><span id="110d" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">mkList :: forall a. a -&gt; [a]</span></pre><p id="772b" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">What’s up with that <code class="fw ke kf kg ka b">forall</code>? Do we need it? And why?</p><h1 id="3806" class="ld jz bq bp fo le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt da" data-selectable-paragraph="">Generic parameters</h1><p id="9227" class="it iu bq iv b iw lu iy iz ja lv jc jd je lw jg jh ji lx jk jl jm ly jo jp jq go da" data-selectable-paragraph="">A friend of mine shared his intuition about generic parameters: “<em class="lz">I always saw them as type placeholders and that every </em><code class="fw ke kf kg ka b"><em class="lz">a</em></code><em class="lz"> had to be same, e.g. once </em><code class="fw ke kf kg ka b"><em class="lz">a</em></code><em class="lz"> is </em><code class="fw ke kf kg ka b"><em class="lz">String</em></code><em class="lz">, all occurrences of </em><code class="fw ke kf kg ka b"><em class="lz">a</em></code><em class="lz"> are </em><code class="fw ke kf kg ka b"><em class="lz">String</em></code>".</p><p id="fe23" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">A reasonable assumption, but not quite true :-)</p><p id="8fca" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">Consider this:</p><pre class="jr js jt ju jv jw jx ee"><span id="9fa4" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">f :: Read a =&gt; String -&gt; [a]<br>f s = g ("[" ++ s ++ "]")<br>   where<br>      g :: String -&gt; a<br>      g a = read a</span></pre><p id="b105" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">This program wouldn’t compile. Can you guess why?</p><p id="dff7" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">If you stare at it long enough, you can notice that there is no good way to substitute <code class="fw ke kf kg ka b">a</code>: if you say that <code class="fw ke kf kg ka b">a ~ Int</code>, then <code class="fw ke kf kg ka b">f :: String -&gt; [Int]</code>, but <code class="fw ke kf kg ka b">g :: String -&gt; Int</code>, so the return types don’t match.</p><p id="c4a2" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">A very reasonable analysis. And yet, the following <em class="lz">does</em> work:</p><pre class="jr js jt ju jv jw jx ee"><span id="b5d3" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">f :: Read a =&gt; String -&gt; [a]<br>f s = g ("[" ++ s ++ "]")<br>   where<br>      g :: Read a =&gt; String -&gt; a<br>      g a = read a</span></pre><p id="fb87" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">I just added a <code class="fw ke kf kg ka b">Read a</code> constraint to the signature of <code class="fw ke kf kg ka b">g</code>, and now it works! Why? There is clearly still no good way to substitute <code class="fw ke kf kg ka b">a</code>, but somehow that doesn’t matter.</p><h1 id="339b" class="ld jz bq bp fo le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt da" data-selectable-paragraph="">Scope</h1><p id="7494" class="it iu bq iv b iw lu iy iz ja lv jc jd je lw jg jh ji lx jk jl jm ly jo jp jq go da" data-selectable-paragraph="">The answer is that <strong class="iv ma">the </strong><code class="fw ke kf kg ka b"><strong class="iv ma">a</strong></code><strong class="iv ma"> in </strong><code class="fw ke kf kg ka b"><strong class="iv ma">f</strong></code><strong class="iv ma"> and the </strong><code class="fw ke kf kg ka b"><strong class="iv ma">a</strong></code><strong class="iv ma"> in </strong><code class="fw ke kf kg ka b"><strong class="iv ma">g</strong></code><strong class="iv ma"> are not the same </strong><code class="fw ke kf kg ka b"><strong class="iv ma">a</strong></code><strong class="iv ma">! </strong>They’re two different, independent type variables, that just happen to be namesakes. When the call <code class="fw ke kf kg ka b">g ("[" ++ s ++ "]")</code> is made, the compiler makes a substitution <code class="fw ke kf kg ka b">g.a ~ [f.a]</code>, and it all works out.</p><p id="57a8" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">That’s the default Haskell rule for type variable scope: type variables are scoped just to the signature in which they appear, and no further. Oh, except in type classes, where they’re scoped to the whole body of the type class. A bit confusing, isn’t it?</p><h1 id="f80f" class="ld jz bq bp fo le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt da" data-selectable-paragraph="">Explicit scope</h1><p id="cb29" class="it iu bq iv b iw lu iy iz ja lv jc jd je lw jg jh ji lx jk jl jm ly jo jp jq go da" data-selectable-paragraph="">It is possible to explicitly control the way that type variables are scoped. In Haskell, we need <code class="fw ke kf kg ka b">ScopedTypeVariables</code> and <code class="fw ke kf kg ka b">ExplicitForall</code> to do that. With these extensions enabled (note that the former will automatically turn on the latter), one can use <code class="fw ke kf kg ka b">forall</code> in function type signatures:</p><pre class="jr js jt ju jv jw jx ee"><span id="cca5" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">f :: forall a. Read a =&gt; String -&gt; [a]<br>f s = g ("[" ++ s ++ "]")<br>   where<br>      g :: String -&gt; [a]<br>      g a = read a</span></pre><p id="dbfa" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">Now the type variable <code class="fw ke kf kg ka b">a</code> is scoped to the whole body of <code class="fw ke kf kg ka b">f</code> — including <code class="fw ke kf kg ka b">g</code> and its signature. That’s why I don’t need an extra <code class="fw ke kf kg ka b">Read a</code> constraint on <code class="fw ke kf kg ka b">g</code> — that constraint already comes from the signature of <code class="fw ke kf kg ka b">f</code>. And of course, now that it’s the same <code class="fw ke kf kg ka b">a</code> in both signatures, I had to change the return type of <code class="fw ke kf kg ka b">g</code> from <code class="fw ke kf kg ka b">a</code> to <code class="fw ke kf kg ka b">[a]</code> .</p><h1 id="571e" class="ld jz bq bp fo le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt da" data-selectable-paragraph="">Analogy to values</h1><p id="e4ae" class="it iu bq iv b iw lu iy iz ja lv jc jd je lw jg jh ji lx jk jl jm ly jo jp jq go da" data-selectable-paragraph="">In Haskell the <code class="fw ke kf kg ka b">forall</code> is still optional, even when it’s allowed, but in PureScript it’s required everywhere. Why would that be? Isn’t it nicer to have type variables just sort of “appear” and not bother with that extra <code class="fw ke kf kg ka b">forall</code>?</p><p id="c7cd" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">Personally, I find explicit <code class="fw ke kf kg ka b">forall</code> useful, because it makes the code more rigid and obvious. Consider the following lambda-expression:</p><pre class="jr js jt ju jv jw jx ee"><span id="dd82" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">f = \x -&gt; x + 1</span></pre><p id="2528" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">Wouldn’t it be nicer not to write the lambda part? What if we could write this:</p><pre class="jr js jt ju jv jw jx ee"><span id="968b" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">f = x + 1</span></pre><p id="8d30" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">and have the compiler sort of “assume” that <code class="fw ke kf kg ka b">x</code> is a free variable in that expression?</p><p id="12bf" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph="">Sounds crazy? But that’s exactly what we do with types!</p><pre class="jr js jt ju jv jw jx ee"><span id="ae32" class="da jy jz bq ka b ci kb kc r kd" data-selectable-paragraph="">At value level:<br>   We write:                \x -&gt; Just x<br>   We wish we could write:  Just x</span><span id="a22d" class="da jy jz bq ka b ci mb mc md me mf kc r kd" data-selectable-paragraph="">At type level:<br>   We write:                forall a. Maybe a<br>   We wish we could write:  Maybe a</span></pre><p id="ea6c" class="it iu bq iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq go da" data-selectable-paragraph=""><code class="fw ke kf kg ka b">forall</code> plays the role of <code class="fw ke kf kg ka b">lambda</code> at the type level.</p></div></div></section></div></article></div></div>






</body></html>